# A Gentle Introduction to SuperCollider
This .md is translation into Japanese a very good tutorial book "A Gentle Introduction to SuperCollider (2nd edition)" published by Bruno Ruviaro. (Work In Progress) 

You can see the original book file here. https://works.bepress.com/bruno-ruviaro/3/

![1569163432316.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/b8fef7e8-3ae8-f8b3-e386-12e8385c7e1d.png)
This work is licensed under the Creative Commons
Attribution-ShareAlike 4.0 International License.
https://creativecommons.org/licenses/by-sa/4.0/deed.ja

![coverart](https://github.com/dauuricus/Supercollider-tutorial-book/blob/master/f6e53a53-af4d-401b-b965-5a26e3e6d352.png?raw=true)

------

 **サンタクララ大学**

 **学者コモンズ**

------

Faculty Book Gallery

------

  **2014**

#  SuperColliderの優しい紹介(第2版)

 

 **ブルーノ・ルヴィアーロ**

  *サンタクララ大学* 、bruviaro@ scu.edu

  Follow this and additional works at: http://scholarcommons.scu.edu/faculty_books

 

Part of the [Composition Commons](http://network.bepress.com/arts-and-humanities/music/composition/?utm_campaign=PDFCoverPages&utm_medium=PDF&utm_source=scholarcommons.scu.edu%2Ffaculty_books%2F91)

推奨される引用

 

 ルヴィアーロ、ブルーノ、**"SuperColliderの優しい紹介(第2版)"(2014年)**。 教員ブックギャラリー. 91.

 http://scholarcommons.scu.edu/faculty_books/91

 この本は、Scholar Commonsが無料でオープンアクセスで提供しています。 Scholar Commonsの認定管理者により、Faculty Book Galleryへの掲載が認められています。 詳細については、 rscroggin @ scu.eduにお問い合わせください 。

![1569163002975.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/d258b0a8-229b-8821-6af4-2ca3b8021549.png)
  

#  SuperColliderの優しい紹介



### 著者　ブルーノ・ルヴィアロ

### 翻訳　[ねことほんだな](https://twitter.com/l_o_0_0_o_1/status/1181474516045725696)


 ![1569163432316.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/b8fef7e8-3ae8-f8b3-e386-12e8385c7e1d.png)



 この作品は、Creative Commons Attribution-ShareAlike 4.0 International Licenseの下でライセンスされています。 このライセンスのコピーを表示するには、次をご覧ください。

 http://creativecommons.org/licenses/by-sa/4.0/

 

[TOC]

Contents

 **I BASICS** 	**p-1**

 1 Hello World	**p-1**

 2 サーバーと言語	**p-3**

 2.1 サーバーの起動	**p-4**

 3 最初の正弦波	**p-4**

 4 エラーメッセージ	**p-5**

 5 パラメーターの変更	**p-7**

 6 コメント	**p-8**

 7 優先順位	**p-9**

 8 最後の投稿は常に投稿されます	**p-9**

 9 コードブロック	**p-10**

 10 Post ウィンドウをクリーンアップする方法	**p-11**

  i

 11 SuperColliderの出力の記録	**p-11**

 12 変数	**p-12**

 12.1 "グローバル"とローカル	**p-13**

 12.2 再割り当て	**p-15**

 **II パターン**	**p-16**

 13 パターンファミリー	**p-16**

 13.1 Pbindに会います	**p-16**

 13.2 Pseq	**p-17**

 13.3 コードを読みやすくします	**p-18**

 13.4 ピッチを指定する4つの方法	**p-19**

 13.5 その他のキーワード：振幅とレガート	**p-21**

 13.6 ブランド	**p-22**

 13.7 Pwhite	**p-23**

 13.8 パターンの語彙を増やす	**p-25**

 14 その他のパターントリック	**p-29**

 14.1 コード	**p-29**

 14.2 スケール	**p-29**

 14.3 転置	**p-30**

 14.4 マイクロトーン	**p-31**

 14.5 テンポ	**p-31**

 14.6 休符	**p-32**

 14.7 複数のPbindを一緒にプレイする	**p-32**

 ii

 14.8 変数の使用	**p-34**

 15 Pbindを個別に起動および停止する	**p-36**

 15.1 楽譜としてのバインド	**p-36**

 15.2 EventStreamPlayer	**p-37**

 15.3 例	**p-38**

 **III 言語について**	**p-41**

 16 オブジェクト、クラス、メッセージ、引数	**p-41**

 17 レシーバー表記、機能表記	**p-43**

 18 ネスティング	**p-44**

 19 エンクロージャー	**p-47**

 19.1 引用符	**p-48**

 19.2 括弧	**p-48**

 19.3 ブラケット	**p-48**

 19.4 中括弧	**p-49**

 20 条件：if / elseおよびcase	**p-50**

 21 関数	**p-53**

 22 配列の楽しみ	**p-55**

 22.1 新しい配列の作成	**p-56**

 iii

 22.2 その面白い感嘆符	**p-57**

 22.3 括弧の間の2つのドット	**p-57**

 22.4 配列を"実行"する方法	**p-58**

 23 困ったときは	**p-59**

 **IV 音声合成と処理**  **p-62**

 24 UGens	**p-62**

 24.1 マウス制御：インスタントテルミン	**p-63**

 24.2 のこぎりとパルス。 プロットとスコープ	**p-63**

 25 音声レート、制御レート	**p-64**

 25.1 poll メソッド	**p-66**

 26 UGen引数	**p-67**

 27 スケーリング範囲	**p-68**

 27.1 メソッドの範囲に合わせてスケーリングします	**p-68**

 27.2 mulでスケーリングして追加します	**p-69**

 27.3 リンリンと友人	**p-70**

 28 個々のシンセの停止	**p-71**

 29 設定メッセージ	**p-71**

 iv

 30 オーディオバス **p-72**

 30.1 アウトおよびイン UGens	**p-72**

 31 マイク入力	**p-75**

 32 マルチチャンネル拡張	**p-76**

 33 バスオブジェクト	**p-78**

 34 パン	**p-79**

 35 ミックスアンドスプレイ	**p-81**

 36 オーディオファイルの再生	**p-83**

 37 シンセノード	**p-84**

 37.1 輝かしいdoneAction：2	**p-85**

 38 エンベローブ	**p-86**

 38.1 Env.perc	**p-87**

 38.2 Env.triangle	**p-87**

 38.3 Env.linen	**p-88**

 38.4 Env.pairs	**p-88**

 38.4.1 エンベロープ-振幅だけではありません	**p-89**

 38.5 ADSR エンベロープ	**p-89**

 38.6 EnvGen	**p-91**

​					 v

 39 シンセの定義	**p-92**

 39.1 SynthDef および Synth	**p-92**

 39.2 例	**p-93**

 39.3 ボンネットの下	**p-96**

 40 Pbind は SynthDef をプレイできます		**p-96**

 41 コントロールバス	**p-99**

 41.1 asMap	**p-100**

 42 実行順序	**p-101**

 42.1グループ	**p-104**

 **V  次は？**	**p-106**

 43 MIDI	**p-106**

 44 OSC	**p-109**

 44.1 別のコンピューターからのOSCの送信	**p-110**

 44.2 スマートフォンからのOSCの送信	**p-110**

 45 クォークとプラグイン	**p-111**

 46 追加リソース	**p-111**

​					vi

  

**SuperColliderの優しい紹介**

 ブルーノ・ルヴィアーロ

2014年9月6日



## Part I

### BASICS

###  1 Hello World

 最初のSuperColliderプログラムを作成する準備はできましたか？ SCが稼働していると仮定します。

 あなたの前で、新しいドキュメントを開き(menu File→New, もしくはショートカット [ctrl+N]) 、次の行を入力します。

```c
"Hello World".postln;
```

 その行の任意の場所にカーソルを置きます(開始、中間、終了のいずれでもかまいません)。 [ctrl + Enter]を押してコードを評価します。 “Hello world” がPost ウィンドウに表示されます。おめでとうございます！それがあなたのはじめてのSuperColliderプログラムでした。



 **p-1**

 

![1569208635624.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/fd36067e-c4ed-041b-07dc-80f21dd062d1.png)図1：SuperCollider IDEインターフェース。図1：SuperCollider IDEインターフェース。

| ヒント：このドキュメント全体を通して、ctrl(コントロール)は、LinuxおよびWindowsプラットフォームで使用されるキーボードショートカットのmodifierキーを示します。Mac OSXでは、代わりにcmd(コマンド)を使用します。 |
| ------------------------------------------------------------ |
| 図1は、最初にSuperCollider IDE(統合開発環境)を開いたときのスクリーンショットです。少し時間をかけて理解していきましょう。 |

 SuperCollider IDEとは何ですか？ これは、"SuperCollider専用に開発されたクロスプラットフォームのコーディング環境(...)であり、使いやすく、経験豊富なコーダー向けの強力な機能が散りばめられています。 また、非常にカスタマイズ可能です。それはMac OSX、Linux、Windowsでも同様に動作します。 "*



 **p-2**



 SCウィンドウに表示される主な部分は、コードエディター、ヘルプブラウザー、およびPost ウィンドウです。 SuperColliderを開いたときにこれらのいずれも表示されない場合は、メニューに移動します。

 View→Docklets (そこから各ドックレットを表示または非表示にできます)。 ステータスバーもあり、常にウィンドウの右下隅にあります。

 そこにプリントされているものすべてをまだ理解していない場合でも、常にPostウィンドウを表示したままにします。 Post ウィンドウには、コマンドに対するプログラムの応答(コード評価の結果、さまざまな通知、警告、エラーなど)が表示されます。

| ヒント：ショートカット [Ctrl ++] および [Ctrl +-] でエディターのフォントサイズを一時的に拡大および縮小できます(それぞれコントロールキーとプラスキーまたはマイナスキー)。 実際のプラスキーを持たないラップトップを使用している場合は、[Ctrl + shift + =] を使用します。 |
| ------------------------------------------------------------ |
|                                                              |

###  2 サーバーと言語

 ステータスバーには、" Interpreter "と"Server"という言葉が表示されます。Interpreterはデフォルトでオン("Active")になり、"Server"はオフになります(すべてゼロが意味します)。 Interpreterとは何ですか？Serverとは何ですか？

 SuperColliderは実際には、サーバーと言語の2つの異なるアプリケーションで構成されています。 サーバーは、音を出す責任があります。 言語(クライアントまたはインタープリターとも呼ばれる)は、サーバーの制御に使用されます。 最初は scsynth(SC-synthesizer) と呼ばれ、2番目は sclang(SC-language) と呼ばれます。 ステータスバーには、これら2つのコンポーネントのステータス(オン/オフ)が表示されます。



------

*SuperColliderドキュメントから引用： [http](https://translate.googleusercontent.com/translate_c?depth=1&hl=ja&rurl=translate.google.com&sl=en&sp=nmt4&tl=ja&u=https://www.google.com/url%3Fq%3Dhttp://doc.sccode.org/Guides/SCIde.html%26sa%3DD%26ust%3D1568980532117000&xid=17259,1500003,15700021,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhhI-oz_2-r-GOndY-3n_5r73wYV7Q)://doc.sccode.org/Guides/SCIde.html IDEインターフェースの詳細については、そのページをご覧ください。

 

 **p-3**



  この区別が今あなたにとってあまり意味をなさない場合でも心配しないでください。 この時点で知っておく必要がある2つの主なものは次のとおりです。

1. SuperColliderに入力するすべてのものは、SuperCollider言語(クライアント)で作成されます。ここでコマンドを記述および実行し、Postウィンドウに結果を表示します。

2. SuperColliderでサウンドを生成するものはすべて、サーバーから送られます。つまり、いわば"サウンドエンジン"です、あなたによってSuperCollider言語を通じてコントロールされます。



###  2.1 サーバーの起動

 "Hello World"プログラムは音を出しませんでした。すべては言語で行われ、サーバーはまったく使用されませんでした。 次の例では音が出ますので、サーバーが稼働していることを確認する必要があります。

 サーバーを起動する最も簡単な方法は、ショートカット [ctrl + B] を使用することです。 または、ステータスバーのゼロをクリックすることもできます。メニューがポップアップし、オプションの1つが"Boot Server"です。サーバーが起動すると、Post ウィンドウにアクティビティが表示されます。 サーバーを正常に起動すると、ステータスバーの数字が緑色に変わります。 SCを起動するたびにこれを行う必要がありますが、セッションごとに1回だけです。

###  3 最初の正弦波

 "Hello World" は伝統的に、新しいプログラミング言語を学ぶときに人々が作成する最初のプログラムです。SuperColliderで既にそれを行っています。

 単純な正弦波の作成は、コンピューター音楽言語の "Hello World" かもしれません。 すぐにジャンプしましょう。 次のコード行を入力して評価します。 注意してくだい。これは大きな音になる場合があります。ボリュームを完全に下げ、ラインを評価してから、ゆっくりボリュームを上げます。



 **p-4**



```c
{SinOsc.ar}.play;
```

 それは美しく、滑らかで、連続的で、おそらく少し退屈なサイン波です。 [ctrl +.]でサウンドを停止できます(コントロールキーとピリオドキーです)。このキーの組み合わせを覚えておいてください。SCのすべてのサウンドを停止するために頻繁に使用するためです。 次に、この正弦波をもう少し面白くしましょう。 これを入力してください：

```c
{SinOsc.ar(LFNoise0.kr(10).range(500, 1500), mul: 0.1)}.play;
```

 行内の任意の場所にカーソルを置いて、[ctrl + Enter]を 押すだけで評価できます。 または、評価する前に行全体を選択することもできます。

| ヒント：コード例を自分で入力することは、優れた学習ツールです。 自信をつけ、言語に慣れるのに役立ちます。 デジタル形式のチュートリアルを読むとき、サンプルから短いコードスニペットをコピーして貼り付けたいと思うかもしれません。 それで問題ありませんが、自分で入力すればもっと学習できます。少なくともSC学習の最初の段階で試してみてください。 |
| ------------------------------------------------------------ |
|                                                              |

###  4 エラーメッセージ

 最後の例を評価しても音がしませんか？ その場合、コードにタイプミスがあった可能性があります。間違った文字、カンマや括弧の欠落などです。コードに問題が発生すると、Postウィンドウにエラーメッセージが表示されます。 エラーメッセージは長くて不可解なことがありますが、パニックにならないでください。時間の経過とともにエラーメッセージの読み方を学びます。 短いエラーメッセージは次のようになります。

```c
ERROR: Class not defined.
	in file ’selected text’
	line 1 char 19:
 	{SinOsc.ar(LFNoiseO.kr(12).range(400, 1600), mul: 0.01)}.play;
-----------------------------------
nil
```

 このエラーメッセージは、"クラスが定義されていません"と表示され、エラーのおおよその場所("行1文字19")を指します。 SCのクラスは、大文字で始まる青い単語( SinOsc や LFNoise0 など)です。 このエラーは、ユーザーが最後に大文字の"O"を付けて LFNoiseO を入力したことが原因であることがわかりました。 正しいクラスは LFNoise0 で、末尾に数字のゼロがあります。 ご覧のとおり、細部への注意が重要です。

 コードにエラーがある場合は、校正して、必要に応じて変更し、修正されるまで再試行してください。 最初にエラーが発生していなかった場合は、エラーメッセージがどのように表示されるかを確認できるように、今すぐ導入してみてください(たとえば、コンマを削除します)。

| ヒント：SuperColliderの学習は、ドイツ語、ポルトガル語、日本語などの別の言語を学習するようなものです。そのまま話そうとし、語彙を増やし、文法と構文に注意を払い、間違いから学びましょう。 ここで起こり得る最悪の事態は、SuperColliderをクラッシュさせることです。 サンパウロで間違ったバスに乗るほど悪くはありませんが、道順の要求が誤解されています。 |
| ------------------------------------------------------------ |
|                                                              |



**p- 6**



###  5 パラメーターの変更

 SuperCollider Bookの最初の章から改作された素晴らしい例があります。*前の例と同様に、すべてを理解しようとして心配する必要はありません。 音の結果を楽しんで、数字で遊んでください。

```c
 {RLPF.ar(Dust.ar([12, 15]), LFNoise1.ar([0.3, 0.2]).range(100, 3000), 0.02)}.play;
```

 

 サウンドを停止し、いくつかの数値を変更して、もう一度評価してください。 たとえば、数字12と15を1と5の間の小さい数字に置き換えるとどうなりますか？ LFNoise1 の後、0.3と0.2の代わりに1と2のようなものを試してみたらどうでしょうか？ 一度に1つずつ変更します。 新しいサウンドを以前のサウンドと比較し、違いを聞いてください。 何が何を支配しているかを理解できるかどうかを確認してください。 これは、SuperColliderを探索する楽しい方法です。何か面白いものを作成するコードスニペットを取得し、パラメーターをいじってバリエーションを作成します。 すべての数字の役割を完全に理解していなくても、興味深い音の結果を見つけることができます。

| ヒント：他のソフトウェアと同様に、[ctrl + S]を使用して作業内容を頻繁に保存してください。 このようなチュートリアルで作業する場合、提供されているサンプルを使用して実験することで、興味深いサウンドを思いつくことがよくあります。 好きなものを残したい場合は、コードを新しいドキュメントにコピーして保存します。 すべてのSuperColliderファイルには、"SuperCollider Document"を表す拡張子.scdがあります。 |
| ------------------------------------------------------------ |
|                                                              |

------

*Wilson,S.とCottle,D.とCollins、N.(編集者)。 SuperCollider Book,MIT Press,2011,p. 5.

 チュートリアルのいくつかの内容は、SuperCollider Bookの最初の章であるDavid Cottleの優れた"Beginner’s Tutorial"から借用、改作、またはインスピレーションを受けています。 このチュートリアルでは、Cottle の章からいくつかの例と説明を借用しますが、それとは異なり、コンピューター音楽への露出が少ないと想定し、教育的アプローチのバックボーンとしてパターンファミリーを紹介します。



**p-7**



###  6 コメント

 コード内の赤色で表示されるテキストはすべてコメントです。 プログラミング言語を初めて使用する場合、コメントは、自分自身と後で読む必要のある人にとって、コードを文書化するのに非常に便利な方法です。 二重スラッシュで始まる行はコメントです。 有効なコード行の直後にコメントを書くことができます。 評価の際、コメント部分は無視されます。 SCでは、セミコロンを使用して有効なステートメントの終わりを示します。

```c
2 + 5 + 10 − 5; // ただ計算するだけ

rrand(10, 20);   // 10∼20の乱数を生成します
```

 カーソルがその行の後のコメントの途中にある場合でも、行を評価できます。 コメント部分は無視されます。 次の2つの段落は、例のためだけに"コメント"として記述されます。

```c
//ショートカット[ctrl + /]を使用して、1行のコードをすばやくコメントアウトできます。

"Some SC code here...".postln;2

2 + 2;

//本当に長いコメントを書くと、あなたのテキストは二重スラッシュで*開始*されない新しい行。 まだ1行のコメントとしてカウントされます。

/*"スラッシュ+アスタリスク"を使用して、複数の行で長いコメントを開始します。 "アスタリスク+スラッシュ"で大きなコメントチャンクを閉じます。 上記のショートカットも大きなチャンクに対して機能します。コメントアウトするコードの行を選択し、[ctrl + /]を押します。 コメント解除と同じです。 */
```



 **p-8**



###   7 優先順位

 SuperColliderは、操作に関係なく、左から右の優先順位に従います。これは、たとえば、乗算が最初に発生しないことを意味します。

```c
// 高校では、結果は9でした。 SCでは、14です。

5 + 2 * 2;

// 括弧を使用して、特定の操作順序を強制します。

5 + (2 * 2); // 9に等しい。
```

 

 メッセージとバイナリ操作を組み合わせる場合、メッセージが優先されます。 たとえば、5 + 2.squared では、平方が最初に発生します。



###  8 最後の投稿は常に投稿されます

 小さくても役に立つ詳細：デフォルトで、SuperColliderは最後に評価されたものの結果を常にPostウィンドウに投稿します。 これは、評価時に Hello World コードが2度プリントされる理由を説明しています。 新しいドキュメントに次の行を入力し、[ctrl + A]ですべてを選択して、すべての行を一度に評価します。

```c
"最初の行".postln;
"2行目".postln;
(2 + 2).postln;
3 + 3;
"完了".postln;
```

 5行すべてがSuperColliderによって実行されます。 明示的な postln 要求があったため、Postウィンドウに2 + 2の結果が表示されます。 3 + 3 の結果が計算されましたが、投稿するリクエストがなかったため、表示されません。 次に、最後の行のコマンドが実行されます(



 **p-9**

  

 postln リクエストにより、"Finished" という単語が投稿されます)。 最終的に、最後に評価されたものの結果がデフォルトで投稿されます。この場合、たまたま　"Finished" という単語でした。

###  9 コードブロック

 評価する前に複数行のコードを選択するのは面倒です。 コードブロックを一度に実行するはるかに簡単な方法は、コードブロックを作成することです。一緒に実行するすべてのコード行をかっこで囲むだけです。 以下に例を示します。

```c
(
// A little poem
"Today is Sunday".postln;
"Foot of pipe".postln;
"The pipe is made of gold".postln;
"It can beat the bull".postln;
)
```



 外側の括弧はコードブロックを区切ります。 カーソルが括弧内の任意の場所にある限り、単一の [ctrl + Enter] がすべての行を評価します(上から下の順に実行されますが、非常に高速なので同時実行されているように見えます)。

 コードブロックを使用すると、何かを変更して再評価するたびにすべての行を再度選択する必要がなくなります。 たとえば、二重引用符で囲まれた一部の単語を変更し、変更した直後に [ctrl + Enter] を押します。 すべての行を手動で選択することなく、コードブロック全体が評価されます。 SuperColliderはブロックを1秒間ハイライトして、実行されている内容の視覚的なヒントを提供します。



**p-10**



###  10 Post ウィンドウをクリーンアップする方法

 これは、独自のセクションに相応しいフリークをクリーニングするのに非常に便利なコマンドでです。[ctrl + shift + P] . この行を評価して、後でPostウィンドウをきれいにしてください：

```c
100.do({"この行を繰り返しptint...".scramble.postln});
```

 どういたしまして。



###  11 SuperColliderの出力の記録

 すぐに SuperCollider パッチのサウンド出力の録音を開始する必要があります。 そのための簡単な方法を次に示します。

```c
//クイックレコード
//記録を開始：
s.record;
//クールなサウンドを作成する
{Saw.ar(LFNoise0.kr([2,3]).range(100,2000),LFPulse.kr([4,5])* 0.1)}.play;  
//記録を停止する：
s.stopRecording;
//オプション：録音ボタン、ボリュームコントロール、ミュートボタンを備えたGUI：
s.makeWindow;
```



 Post ウィンドウには、ファイルが保存されたフォルダーのパスが表示されます。 ファイルを見つけて、Audacityまたは同様のプログラムで開き、サウンドが実際に録音されたことを確認します。 詳細については、"サーバー"ヘルプファイルを参照してください( “Recording Support” までスクロールします)。 または、オンラインで http://doc.sccode.org/Classes/Server.html



**p-11**



###  12 変数

 数値、words、unit ジェネレーター、関数、またはコードブロック全体を変数に保存できます。 変数は、1文字またはユーザーが選択した単語全体です。 等号(=)を使用して変数を"割り当て"ます。 これらの行を一度に1つずつ実行し、Post ウィンドウを監視します。

```c
 x = 10;
 y = 660;
 y; // 内容を確認します
 x;
 x + y;
 y − x; 
```



 最初の行は、変数xに数値10を割り当てます。 2行目は、変数yに660を入れます。 次の2行は、これらの文字がこれらの数字(データ)を"含む"ことを証明しています。 最後に、最後の2行は、変数を使用してデータを操作できることを示しています。 小文字のa∼zは、SuperColliderの変数としていつでも使用できます。 慣例により使用しない唯一の文字はsであり、これはデフォルトでサーバーを表します。 何でも変数に入れることができます：

 

```c
a = "Hello,World"; // 文字列
b = [0,1,2,3,5]; // リスト
c = Pbind(\note,Pwhite(0,10),\dur,0.1); // 後でPbindについてすべて学習します。心配しないでください

// ...そして元のデータを使用するのと同じように使用できるようになりました：
a.postln; // 投稿する
b + 100; // 計算を行います
c.play; // そのPbindを再生します
d = b * 5; // bを取り、5を掛けて、それを新しい変数に割り当てます
```

 

**p-12** 



 多くの場合、変数に適切な名前を付けて、コード内で変数が何を表しているのかを思い出すのに役立ちます。 ∼ (チルダ)を使用して、より長い名前の変数を宣言できます。 チルダと変数名の間にスペースがないことに注意してください。

```c
∼myFreqs = [415,220,440,880,220,990];  
∼myDurs = [0.1,0.2,0.2,0.5,0.2,0.1];  

Pbind(\freq,Pseq(∼myFreqs),\dur,Pseq(∼myDurs)).play; 
```

 

 変数名は小文字で始まる必要があります。 名前には、最初の文字としてではなく、数字、アンダースコア、大文字を使用できます。 すべての文字は連続している必要があります(スペースや句読点は使用できません)。 要するに、変数に名前を付けるときは、文字と数字、およびときどきアンダースコアを使用することし、他のすべての文字を避けてください。 ∼myFreqs,∼theBestSineWave,および∼banana_3は有効な名前です。

 ∼MyFreqs,∼theBest＆*＃SineWave,および∼banana!!! これらは悪い名前です。

 作成できる変数には、"グローバル"変数とローカル変数の2種類があります。

 

###  12.1 "グローバル"とローカル

 これまでに見た変数(単一の小文字aからz、およびチルダ(∼)文字を含む)は、大まかに"グローバル変数"と呼ばれる場合があります。宣言されると、SuperColliderを終了するまで、パッチのどこでも、他のパッチでも、他のSCドキュメントでも"グローバルに"動作します。 *



------

*技術的には、チルダで始まる変数は環境変数と呼ばれ、小文字の変数(a∼z)はインタープリター変数と呼ばれます。 SuperColliderの初心者は、これらの違いを心配する必要はありませんが、将来のために心に留めておいてください。 SuperColliderブックの第5章では、違いについて詳しく説明しています。

 

**p-13**

 

 一方、ローカル変数は、行の先頭で予約キーワード var で宣言されます。 宣言時に変数に初期値を割り当てることができます (var apples = 4) 。 ローカル変数は、そのコードブロックのスコープ内にのみ存在します。 

 以下に、2種類の変数を比較する簡単な例を示します。 行ごとに評価し、Post ウィンドウを監視します。

```c
// 環境変数
∼galaApples = 4;

∼bloodOranges = 5;
∼limes = 2;
∼plantains = 1;

[["Citrus", ~bloodOranges + ~limes ];  
["Non−citrus", ~plantains + ~galaApples ];  

// ローカル変数：コードブロック内でのみ有効。
// ブロックを1回評価して、Post ウィンドウを見る：
(
var apples = 4,oranges = 3,lemons = 8,bananas = 10;
["Citrus fruits", oranges + lemons].postln;  
["Non−citrus fruits", bananas + apples].postln;  
"End" .postln;
)

~galaApples; // まだ存在しています
apples; // なくなった
```



 **p-14**



###  12.2 再割り当て

 変数について理解する最後の便利な点は、変数を再割り当てできることです。いつでも新しい値を与えることができます。

```c
// 変数を割り当てる
a = 10 + 3;
a.postln; // 確認してください
a = 999; // 変数を再割り当てします(新しい値を与えます)
a.postln; // チェックしてください：古い値はなくなりました。
```



 初心者にとって混乱を招くことがある非常に一般的な方法は、変数自体が独自の再割り当てで使用される場合です。 この例を見てください： 

```c
x = 10; // 変数xに10を割り当てます
x = x + 1; // 変数xにx + 1を割り当てます
x.postln; // 確認してください
```

  最後の行を理解する最も簡単な方法は、

"変数xの現在の値を取得し、それに1を追加し、この新しい結果を変数xに割り当てる"

というように読むことです。

 また、これがどのように役立つかについては後で説明します。*



------

*この例は、プログラミングでの等号が数学で学んだ等号とは異なることを明確に示しています。 数学では、x = x + 1は不可能です(数値をそれ自体に1を足すことはできません)。 SuperColliderのようなプログラミング言語では、等号は一種のアクションと見なすことができます。記号の右側で式の結果を取得し、左側で変数に"代入"します。



 **p-15**



## Part II

### パターン

### 13 パターンファミリー

 新たにこれを試してみましょう。 次のコード行を入力して実行します。 

```c
Pbind(\degree,Pseries(0,1,30),\dur,0.05).play;
```



### 13.1 Pbindに会う

 Pbind は、SuperColliderの Pattern ファミリーのメンバーです。 Pbind および Pseries の大文字Pは、パターン (Pattern) を表します。 私たちはいずれすぐにファミリーの他のメンバーに会います。 とりあえず、Pbind だけを詳しく見てみましょう。 この単純な例を試してください：

```c
Pbind(\degree,0).play;
```

 

 このコード行が実際に行う唯一のことは、1秒間に1回、中央のCを演奏することです。 キーワード \degree は音階を示し、数値0は音階のはじまりを意味します(Cメジャー音階が想定されているため、でだしのC音そのものです)。 SuperColliderは1ではなく0からカウントを開始することに注意してください。上記のような単純な行では、ノートC、D、E、F、G ...は0、1、2、3、4 ...の数字で表されます。 この数字を変更してみて、再評価したときに音がどのように変化するかを確認してください。 負の数を使用して、中央のCの下の音符を選択することもできます(たとえば、-2を使用すると、中央のCの下に音符Aが表示されます)。 要するに、ピアノの中央のC音が0であると想像してから、白鍵を上下に数えて(正または負の数)他の音を取得します。



 **p-16**

  

 次に、音符の長さを少し試してみます。 Pbind はキーワード \dur を使用して、秒単位で期間を指定します。

```c
Pbind(\degree,0,\dur,0.5).play;
```



 もちろん、これは依然として非常に厳格で柔軟性がありません。常に同じ音で、常に同じ持続時間です。 心配しないでください：物事はすぐに良くなります。 しかし、まず、Pbind 内でピッチを指定できる他の方法を見てみましょう。

### 13.2 Pseq

 スケールのように、いくつかの音を順番に演奏してみましょう。また、音符を短く、たとえば0.2秒にしましょう。

```c
Pbind(\degree,Pseq([0,1,2,3,4,5,6,7],1),\dur,0.2).play;
```



 この行は、パターンファミリの新しいメンバーである Pseq を紹介しています。 名前が示すように、このパターンはシーケンスを扱います。 シーケンスを再生するために Pseq に必要なのは次のとおりです。

-  	角括弧で囲まれたアイテムのリスト

-  	多数の繰り返し。

 この例では、リストは [0,1,2,3,4,5,6,7] で、繰り返し回数は1です。この Pseq は、単に"リストのすべての項目を順番に再生する"という意味です。これらの2つの要素、リストと繰り返し回数は、Pseq の括弧内にあり、コンマで区切られていることに注意してください。

 

 Pbind 内の Pseq の位置にも注意してください。これは、\degreeの入力値です。 これは重要です。最初の単純な Pbind のように、スケールの度合いに単一の固定数を提供する代わりに、一連の数のレシピである Pseq 全体を提供しています。 これを念頭に置いて、このアイデアを簡単に拡張し、別の Pseq を使用して継続時間を制御することもできます。 

 

 **p-17**

 

```c
Pbind(\degree,Pseq([0,1,2,3,4,5,6,7],5),\dur,Pseq([0.2,0.1,0.1,0.2,0.2,0.35],inf) ).play;
```

 

 この例では何が起こっていますか？

最初に、最初の Pseq の繰り返し数を5に変更したため、スケール全体が5回再生されます。

次に、以前に固定した0.2の \dur 値を別の Pseq に置き換えました。この新しい Pseq には、6つのアイテムのリストがあります：[0.2,0.1,0.1,0.2,0.2,0.35]。 これらの数値は、結果のノートのデュレーション値になります。

 この2番目の Pseq の繰り返し値は "infinite." を表す inf に設定されます。これは、Pseq がシーケンスを繰り返すことができる回数に制限がないことを意味します。

 Pbind は永遠にプレイしますか？ いいえ：他の Pseq がジョブを終了した後、つまり一連のスケール度が5回再生された後に停止します。



 最後に、この例には合計8つの異なるノート(最初の Pseq のリスト)がありますが、デュレーション(6番目の Pseq )には6つの値しかありません。 このように異なるサイズのシーケンスを提供すると、Pbind は必要に応じて単純に循環します。

 これらの質問に答えて、学んだことを実践してください。

- 2番目の Pseq の repeats 引数として、inf の代わりに数値1を試してください。 	何が起こるのですか？

- この Pbind を永久にプレイするにはどうすればよいですか？

 ソリューションは本の最後にあります。 1

 

### 13.3 コードを読みやすくする

 上記のコード行が非常に長いことに気づいたかもしれません。 実際、技術的には単一のステートメントであるにもかかわらず、新しい行に折り返されるほど長い。 長いコード行は読みにくいかもしれません。 これを回避するには、コードをいくつかのインデントした行に分割するのが一般的です



**p- 18**



  目標は、できるだけ明確でわかりやすいものにすることです。上記と同じ Pbind は、次のように書くことができます。

 

```c
Pbind(
	\degree,Pseq([0,1,2,3,4,5,6,6,7],5),
	\dur,Pseq([0.2,0.1,0.1,0.2,0.2,0.35],inf)
).play;
```



 これからは、このように Pbind を作成する習慣を身に付けてください。 きちんと整理され、きちんと整理されたコードを書くことは、SuperColliderを学ぶ上で大いに役立ちます。

 また、この Pbind を括弧で囲んでコードブロックを作成していることに注意してください(セクション9を思い出してください)。これは1行ではないため、すべてを一緒に実行するためにこれを行う必要があります。 評価する前に、カーソルがブロック内のどこかにあることを確認してください。

 

### 13.4ピッチを指定する4つの方法

 Pbind は、音度（主音との音程に従って、番号を振ったもの）だけでなく、ピッチを指定する他の方法も受け入れます。

-  	12個すべての半音符(ピアノの黒鍵と白鍵)を使用する場合は、\degree の代わりに\note を使用できます。0はミドルC を意味しますが、ステップにはピアノの黒鍵が含まれます(0=middle C, 1=C#, 2=D, etc)。
-  	MIDIノートの番号付けを使用する場合は、\midinote を使用します(60=middle C, 61=C#, 62=D,etc)。
-  	最後に、ヘルツで直接周波数を指定する場合は、\freq を使用します。

 4つの方法すべての比較については、図2を参照してください。

 次の例では、4つの Pbind がすべて同じ音符を演奏します：中央のCの上のA (A4)。 



**p-19**

 

![1569208590557.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/d10a0d70-eec3-8419-3104-17b911ca5fd4.png) 

図2：音階、ノート番号、ミディノット、および周波数の比較

```c
Pbind(\degree,5).play;
Pbind(\note,9).play;
Pbind(\midinote,69).play;
Pbind(\freq,440).play;
```

| ヒント：ピッチ仕様の各タイプは、異なる合理的な範囲の数値を想定していることに注意してください。[-1,0,1,3] のような数字のリストは、\degree や \note には意味がありますが、\midinote や \freq には意味がありません。次の表では、ピアノキーボードを基準として使用していくつかの値を比較しています。 |
| ------------------------------------------------------------ |
|                                                              |

 **p-20**

 

|           | A0 (lowest piano note) | C4    | A4   | C5    | C8 (highest piano note) |
| --------- | ---------------------- | ----- | ---- | ----- | ----------------------- |
| \degree   | -23                    | 0     | 5    | 7     | 21                      |
| \note     | -39                    | 0     | 9    | 12    | 48                      |
| \midinote | 21                     | 60    | 69   | 72    | 108                     |
| \freq     | 27.5                   | 261.6 | 440  | 523.2 | 4186                    |

 

###  13.5 その他のキーワード：振幅とレガート

 次の例では、イベントの振幅と音符間のレガートの量を定義する2つの新しいキーワード \amp と \legato を紹介します。 良いインデントのおかげでコードが非常に読みやすく、複数行に広がっていることに注目してください。 かっこ(上と下)を囲むと、コードブロックを区切ってすばやく実行できます。

 

```c
(
 Pbind(
 	\degree,Pseq([0,-1,2,-3,4,-3,7,11,4,2,0,-3],5),
 	\dur,Pseq([0.2,0.1,0.1],inf),
 	\amp,Pseq([0.7,0.5,0.3,0.2],inf),
 	\legato,0.4
).play;
)
```



  Pbindにはこれらの事前定義されたキーワードの多くがあり、これから詳しく学んでしいきます。 ここではそのうちのいくつか、1つはピッチ（\degree、\note、\midinote、または\freqから選択）、1つはデュレーション（\dur）、1つは振幅（\amp）、1つはレガート（\legato）について取り上げます。 持続時間はビートです(この場合、1秒あたり1ビート、これがデフォルトです)。 振幅は0∼1の間でなければなりません(0 =無音、1 =非常に大きい)。 そして、レガートは0.1から1の間の値で最適に動作します(



 **p-21**



レガートが何をするのかわからない場合は、上記の例を0.1、0.2、0.3の順に1まで試し、結果を聞いてください)。

 最後の例を出発点として、新しい Pbind を作成します。 メロディを変更します。 持続時間と振幅の新しいリストを作成します。 ピッチに \freq を使用して実験します。 必要な場合は、任意のパラメーターに固定数を使用することを常に選択できます。 たとえば、メロディ内のすべての音符の長さを0.2秒にしたい場合、Pseq [0.2,0.2,0.2,0.2 ...を書く必要はなく、Pseq([0.2],inf) でもなく、単に全体の Pseq構造体に0.2を書き込みます。

 

### 13.6 Prand

```c
(
Pbind(
	\degree, Prand([2, 3, 4, 5, 6], inf),
	\dur, 0.15,
	\amp, 0.2,
	\legato, 0.1
).play;
)
```



 Prand を Pseq に置き換えて、結果を比較します。 次に、持続時間、振幅、レガートにPrand を使用してみてください。



 **p-22**

 

### 13.7 Pwhite

 パターンファミリーのもう1つのポピュラーメンバーは Pwhiteです。 これは、等分布乱数ジェネレータです(名前は"ホワイトノイズ"に由来します)。たとえば、Pwhite(100,500) は100から500までの乱数を取得します。

```c
(
Pbind(
	\freq, Pwhite(100, 500),
	\dur, Prand([0.15, 0.25, 0.3], inf),
	\amp, 0.2,
	\legato, 0.3
).trace.play;
)
```



 上記の例は、別の役立つトリックも示しています：再生直前のメッセージトレースです。すべてのイベントに対して選択された値をPostウィンドウに出力します。デバッグや単に何が起こっているかを理解するのに非常に便利です！

 Pwhite と Prand  の違いに注意してください。どちらもランダム性に関係していても、異なる引数を取り、異なることを行います。 Pwhite の括弧内には、Pwhite(low,high) という低い境界と高い境界を指定するだけです。乱数はその範囲内から選択されます。一方、Prand は、項目のリスト(大括弧で囲まれている必要があります)と、多数の繰り返し (Prand([list,of,items],repeats)) を受け取ります。リストからランダムなアイテムが選択されます。

 両方で遊んで、違いを完全に理解してください。



**p-23**



| ヒント：2つの整数を持つ Pwhite は、整数のみを生成します。たとえば、 Pwhite(100,500)は145、568、700などの数値を出力しますが、145.6,450.32 などは出力しません。出力に浮動小数点数が必要な場合は、 Pwhite(100,500.0) と記述します。これは、たとえば、振幅に非常に役立ちます。Pwhite(0,1) を書き込むと、0または1しか得られませんが、 Pwhite(0,1.0) を書くと、すべてが得られます。 |
| :----------------------------------------------------------- |
|                                                              |

 次の質問を試して、新しい知識をテストしてください

​	a) Pwhite(0,10) と Prand([0,4,1,5,9,10,2,3],inf) の出力の違いは何ですか？

​	b) 0から100の間でランダムに選択された整数のストリームが必要な場合、Prand を使用できますか？ 

​	c) Pwhite(0,3) と Prand([0,1,2,3],inf) の出力の違いは何ですか？ Pwhite(0,3.0) と書くとどうなりますか？ 

​	d) 以下の例を実行します。Cマイナースケール(黒鍵を含む)を演奏するために、\degree ではなく \note を使用します。リスト[0,2,3,5,7,8,11,12]には、ピッチC、D、E、F、G、A、B、Cに対応する8つの数字がありますが、それぞれのイベントの数は例は実際にプレイしますか？どうして？

```c
// Pseq
(
Pbind(
	\note, Pseq([0, 2, 3, 5, 7, 8, 11, 12], 4),
	\dur, 0.15;
).play;
)

// Pseq
(
Pbind(
	\note, Prand([0, 2, 3, 5, 7, 8, 11, 12], 4),
	\dur, 0.15;
).play;
)

// Pwhite
(
Pbind(
	\note, Pseq([0, 2, 3, 5, 7, 8, 11, 12], 4),
	\dur, Pwhite(0.15, 0.5);
).play;
)
```



 回答はこのチュートリアルの最後にあります。 2

| ヒント：Pbindは、最短の内部パターンの再生が終了すると、再生を停止します(各内部パターンのrepeats引数によって決定されます)。 |
| ------------------------------------------------------------ |
|                                                              |

### 13.8 パターンボキャブラリーの拡張

 これまでに、自分で簡単なPbindを書くことができるはずです。ピッチ、デュレーション、振幅、レガート値を指定する方法と、他のパターン(Pseq,Prand,Pwhite)を埋め込んで興味深いパラメーター変更を生成する方法を知っています。



**p-25**



 このセクションでは、パターンの語彙を少し増やします。以下の例では、パターンファミリのさらに6つのメンバーを紹介します。彼らが何をするかを自分で考えてみてください。次の戦略を使用します。

-  結果のメロディーを聞きます。あなたが聞いたものを記述し分析する;

-  パターン名を見てください：何かを示唆していますか？(例えば、Pshufは"シャッフル"という言葉を思い出させるかもしれません);

-  新しいパターン内の引数(数字)を確認します。

-  前述の .trace.play を使用して、Postウィンドウに出力される値を確認します。

-  最後に、ヘルプファイルを参照して推測を確認します(パターンの名前を選択し、[ctrl + D]を押して対応するヘルプファイルを開きます)。

```c
// パターンの語彙を増やす

// Pser
(
Pbind(
	\note, Pser([0, 2, 3, 5, 7, 8, 11, 12], 11),
	\dur, 0.15;
).play;
)

// Pxrand
// Prand と比較して違いを聞く
(
p = Pbind(
	\note, Pxrand([0, 2, 3, 5, 7, 8, 11, 12], inf),
	\dur, 0.15;
).play;
)

// Pshuf
(
p = Pbind(
	\note, Pshuf([0, 2, 3, 5, 7, 8, 11, 12], 6),
	\dur, 0.15;
).play;
)

// Pslide
// 4つの引数を使用: list, repeats, length, step
(
Pbind(
\note, Pslide([0, 2, 3, 5, 7, 8, 11, 12], 7, 3, 1),
\dur, 0.15;
).play;
)

// Pseries
// 3つの引数を使用: start, step, length
(
Pbind(
	\note, Pseries(0, 2, 15),
	\dur, 0.15;
).play;
)

// Pgeom
// 3つの引数を使用: start, grow, length
(
Pbind(
\note, Pseq([0, 2, 3, 5, 7, 8, 11, 12], inf),
\dur, Pgeom(0.1, 1.1, 25);
).play;
)

// Pn
(
Pbind(
	\note, Pseq([0, Pn(2, 3), 3, Pn(5, 3), 7, Pn(8, 3), 11, 12], 1),
	\dur, 0.15;
).play;
)
```

 

 これらのパターンの使用を練習します。多くのことができます。 Pbindは楽譜のレシピのようなもので、ノートとリズムの固定シーケンスを書くことに限定されないという利点があります。常に変化する音楽パラメーターのプロセスを記述することができます(これは"algorithmic composition"と呼ばれることもあります)。これは、パターンファミリの強力な機能の1つの側面にすぎません。

 将来的に、より多くのパターンオブジェクトの必要性を感じた場合、最適な場所は、組み込みのヘルプファイルで利用可能なJames Harkinsの"A Practical Guide to Patterns,"です。*

------

*オンラインでも http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_01_Introduction.html



**p-28**



### 14 その他のパターントリック

### 14.1 コード

 Pbinds 内にコードを記述したいですか？それらをリストとして記述します (角括弧で囲まれたコンマ区切り値)：

```c
(
Pbind(
	\note,Pseq([[0,3,7],[2,5,8],[3,7,10] ,[ 5,8,12 ]],3),
	\dur,0.15
).play; 
)
//strum 
(
Pbind(
	\note,Pseq([[-7,3,7 ,10],[ 0,3,5,8 ]],2),
	\dur,1,
	\legato,0.4,
	\strum,0.1 //0,0.1,0.2 などを試す
 ).play;
 )
```



### 14.2 スケール

 ピッチの指定に \degree を使用する場合、キーワード \scale を使用して別の行を追加してスケールを変更できます (注：これは \degree とともにのみ機能し、 \note, \midinote または \freqでは機能しません)：



 **p-29**



```c
(
Pbind(
 \scale,Scale .harmonicMinor,
 \degree,Pseq([0,1,2,3,4,5,6,7],1),
 \dur,0.15;
 ).play;
 )
 
 // この行を評価して、使用可能なすべてのスケールのリストを表示します。
 Scale.directory;
 
 // 1度の間に半音が必要な場合は、これを行います：
 (
 Pbind(
 	\degree,Pseq([0,1,2,3,3.1,4],1),
 ).play;
 )
 
 // 上記の3.1はスケール`3`の上の半音(この場合、Fの上のF＃)を意味します。 \scaleを明示的に指定しない場合、Scale.majorが想定されることに注意してください。
```



### 14.3 移調

 \ctranspose キーワードを使用して、音の移調を実現します。これは、\degree,\note,および \midinote と連動しますが、\freq とは連動しません。

```c
(
Pbind(
	\note,Pser([0,2,3,5,7,8,11,11,12],11),
	\ctranspose,12,//オクターブ上で転置(= 12半音)
	\dur,0.15;
).play;
)
```

 

 **p-30**



### 14.4 マイクロトーン

 マイクロトーンの書き方：

```c
// \note および \midinote を使用したマイクロトーン：
Pbind(\note,Pseq([0,0.5,1,1.5,1.75,2],1)).play;
Pbind(\midinote,Pseq([60,69,68.5,60.25,70],1)).play;
```

 

### 14.5 テンポ

 Pbindの \dur キーに指定する値は拍数です。つまり、1は1拍、0.5は半拍などを意味します。特に指定しない限り、デフォルトのテンポは60 BPM(1分あたりのビート)です。別のテンポで演奏するには、新しいTempoClock を作成するだけです。 120ビート/分(BPM)で再生する Pbind は次のとおりです。 

```c
 (
 Pbind(\degree,Pseq([0,0.1,1,2,3,4,5,6,7]),
 	\dur,1;
 ).play(TempoClock(120/60)); // 60秒間で120ビート：120 BPM
 )
```

 

 ところで、上記の Pseq が引数(リスト)を1つしかとっていないことはわかりましたか？常にリストの後に来る繰り返し値はどこにありますか？サンプルがシーケンスを1回だけ再生するのが聞こえますが、なぜですか？これは、すべてのパターン(および実際、SuperCollider の他の多くのオブジェクト)の共通プロパティです。引数を省略すると、組み込みのデフォルト値が使用されます。この場合、Pseq のデフォルトの繰り返しは1です。 



 **p-31**



 Pbind？これは単なる Pbind(\degree,0).play であり、1つのノートを演奏する方法しか知りませんでした。デュレーション、振幅、レガートなどの情報を提供しませんでした。これらの場合、Pbind はデフォルト値を使用し先に進みます。

### 14.6 休符

 書き方です。休憩内の数字は、休憩の長さをビートで表したものです。休符は、\dur 行だけでなく、Pbind の任意の場所に移動できます。

 

```c
(
Pbind(
	\degree,Pwhite(0,10),
	\dur,Pseq([0.1,0.1,0.3,0.6,Rest(0.3),0.25],inf);
).play;
)
```

 

### 14.7 2つ以上のPbindを一緒に再生

 いくつかのPbindを同時に開始するには,単純にそれらすべてを 1 つのコードブロック内に入れます。

```c
(//大きなブロック
Pbind(
	\freq,Pn(Pseries(110,111,10)),
	\dur,1/2,
	\legato,Pwhite(0.1,1)
).play;
Pbind(
	\freq,Pn(Pseries(220,222,10)),
	\dur,1/4,
	\legato,Pwhite(0.1,1)
).play;
 Pbind(
	\freq,Pn(Pseries(330,333,10)),
	\dur,1/6,
	\legato,0.1
).play;
)//大きなブロックを閉じる
```

 

**p-32**

 

 Pbindを時系列に再生するには(単にそれらを手動で次々に評価する以外),{} .forkを使います：

 

```c
//基本的なフォークの例を使用できます。Postウィンドウを見てください：
(
{
	"one thing".postln;
	2.wait;
	"別のもの".postln;
	1.5.wait;
	"最後の1つ".postln;
}.fork; 
)
//より興味深い例：
(
t = TempoClock(76/60); 
{
Pbind( 
	\note,Pseq([[4,11],[6,9]],32),
	\dur,1/6,
	\amp,Pseq([0.05,0.03],inf)
).play(t);
2.wait;

Pbind(
 	\note,Pseq([[-25,-13,-1],[-20,-8,4 ],\rest],3),25 
 	\dur,Pseq([1,1,Rest( 1)],inf),
 	\amp,0.1,27 \legato,Pseq([0.4,0.7,\rest],inf)
).play(t);
2.75.wait;
 
Pbind(
 	\note,Pseq([23,21,25,23,21,20,18,16,16,20,21,23,21],inf),
	\dur,Pseq([0.25,0.75,0.25,1.75,0.125,0.125,0.80,0.20,0.125,0.125,1],1),
 	\amp,0.1,
 	\legato,0.5
).play(t);
}.fork(t);
)
```

  

**p-33**

 

 Pbind を同時に、順番に再生する高度な方法については、Ppar と Pspawner を確認してください。fork の詳細については、Routine Help ファイルをご覧ください。



### 14.8 変数の使用

 前のセクション"パターンの語彙を拡張する"で,複数の Pbind に対して同じノートリスト [0,2,3,5,7,8,11,12] を何度も入力する必要があることに気付きましたか？同じものを何度も何度もコピーするのは効率的ではありませんか？プログラミングでは、同じタスクを繰り返し実行していることに気付いたときはいつでも、おそらく同じ目標をよりスマートな戦略を採用して達成する必要があります。



**p- 34**

 

 この場合,変数を使用できます。覚えているかもしれませんが、変数を使用すると、データのチャンクを柔軟かつ簡潔に参照できます( 必要に応じてセクション12を 確認してください)。 以下に例を示します。

```c
// 同じ数字のシーケンスをたくさん使用していますか？変数に保存します：
c = [0,2,3,5,7,8,11,11,12]  
// これで参照できます
Pbind(\note,Pseq(c,1),\dur,0.15).play; 
Pbind(\note,Prand(c,6),\dur,0.15).play;
Pbind(\note,Pslide(c,5,3,1),\dur,0.15).play;
```

   

 変数の使用を練習する別の例：2つの Pbind を同時にプレイしたいとしましょう。それらの1つは昇順のメジャースケールを実行し、もう1つは1オクターブ上の降順のメジャースケールを実行します。どちらも同じ durations のリストを使用します。これを記述する1つの方法を次に示します。

```c
∼scale = [0,1,2,3,4,5,6,7];
∼durs = [0.4,0.2,0.2,0.4,0.8,0.2,0.2,0.2];
(
Pbind(
	\degree,Pseq(∼scale),
	\dur,Pseq(∼durs)
).play; 

Pbind(
	\degree,Pseq(∼scale.reverse + 7),
	\dur,Pseq(∼durs)
).play;
)
```

 

 ここで興味深いトリック：変数のおかげで、両方の Pbind に対して同じスケール度とdurations のリストを再利用します。 2番目のスケールが下降し、 最初のスケールより1オクターブ上になるようにしたかった。

 

**p- 35**

 

これを実現するには、単にメッセージ.reverse を使用してリストの順序を逆にします (新しい行に"∼scale.reverse"と入力し、評価して正確にその内容を確認します)。次に7を追加して、1オクターブ上で転置します(テストして結果を確認します)。 *

2つの Pbind を 1つのコードブロックで囲んで同時に再生しました。



 演習：上記のコードブロック内に Pbind を1つ追加して、3つの音声が聞こえるようにします。いくつかの異なる方法で両方の変数( ∼scale および ∼durs )を使用します。たとえば、Pseq 以外のパターン内で使用、移調量を変更、durations を逆にしたり乗算したり、 などなど。

  

### 15 Pbind を個別に起動および停止する

 これは、Pbind、特に inf を使用して永久に実行されるものに関する非常に一般的な質問です。個々の Pbind を自由に停止および起動するにはどうすればよいですか。答えには変数を使用する必要があり、すぐに完全な例が表示されます。しかし、そこに行く前に、Pbind をプレイしたときに何が起こるかをもう少し理解する必要があります。

 

### 15.1 Pbind を楽譜として

 Pbind は、一種の楽譜として考えることができます。Pbind は、音を出すためのレシピであり、音楽のパッセージを実現するための一連の指示です。スコアを音楽にするためには、プレーヤーに与える必要があります。それは、スコアを読み、それらの指示に基づいて音を出す人です。これら2つの瞬間を概念的に分けましょう。スコアの定義とそのパフォーマンスです。

------



*同じ転置を得るために \ctranspose,12 を使用することもできます。



**p-36**



```c
//スコアを定義する
 (
 p = Pbind(
 	\midinote,Pseq([57,62,64,65,67,69],inf),
 	\dur,1/7
 ); //ここでは再生しません！
 )
 
 //プレイするスコアを要求する
 p.play;
```

 

 上記の例の変数pは単にスコアを保持します。Pbind には閉じ括弧の直後に .play メッセージがないことに注意してください。その時点で音は出ません。 2番目の瞬間は、SuperColliderにそのスコアからプレイするように依頼したときです：p.play.

 この時点でよくある間違いは、プレーヤーが停止することを期待して p.stop を試すことです。それを試して、それがこのように機能しないことを自分で確認してください。次の段落でその理由を理解できます。

 

### 15.2 EventStreamPlayer

 [Ctrl] + [Shift] + [P] で[投稿]ウィンドウを消去し(実際には必要ありませんが、なぜそうではないのですか？)、p.play を再度評価します。Post ウィンドウを見ると、結果が EventStreamPlayer と呼ばれるものであることがわかります。Pbind で .play を呼び出すたびに、SuperCollider はそのアクションを実現するプレーヤーを作成します。それが EventStreamPlayer です。"今すぐこの楽譜を演奏したい"と言うたびに、目の前でピアニストが具体化するようなものです。いいですね。

  

 ええ、はい。ただし、この匿名の仮想プレーヤーが表示されてジョブを開始した後は、あなたはそれに話す方法がありません。名前がありません。もう少し技術的に言えば、オブジェクトを作成しましたが、後でそのオブジェクトを参照する方法はありません。たぶん、この時点で、p.stop を実行してもうまくいかない理由がわかるでしょう。プレイヤーと話すのではなく、スコアと話そうとしているようです。

 

 **p-37**

 

 スコア(変数pに格納されている Pbind )は、開始または停止について何も知りません。これは単なるレシピです。プレーヤーは、開始、停止、"最初から始めてください"などを知っている人です。つまり、EventStreamPlayer と話す必要があります。必要なことは、名前を付けること、つまり変数に保存することだけです 。

```c
 //これらの行を1つずつ試します
 ∼myPlayer = p.play;
 ∼myPlayer.stop;
 ∼myPlayer.resume;
 ∼myPlayer.stop.reset;
 ∼myPlayer.start;
 ∼myPlayer.stop;
```



 要約すると、Pbind で .play を呼び出すと、EventStreamPlayer が生成されます。EventStreamPlayers を変数に保存すると、後でそれらにアクセスしてパターンを個別に開始および停止できます([ctrl +.]を使用する必要はありません。すべてを一度に強制終了します)。



### 15.3 例 

 このセクションを締めくくるより複雑な例があります。一番上のメロディーはチャイコフスキーの青少年のためのアルバムから借用されており、より低いメロディーが対位法で追加されています。図3は、楽譜のパッセージを示しています。

  

```c
//スコアを定義する
(
var myDurs = Pseq([Pn(1,5),3,Pn(1,5),3,Pn(1,6),1/2,1/2,1,1,3,1,3] ,inf)* 0.4;
∼upperMelody = Pbind(
\midinote,Pseq([69,74,76,77,79,81,Pseq([81,79,81,82,79,81],2),82,81,79,77,76,74,74 ],inf),
\dur,myDurs
);
∼lowerMelody = Pbind(

\midinote,Pseq([57,62,61,60,59,58,57,55,53,52,50,49,50,52,50,55,53,52,53,55,57,58,
 61,62,62 ],inf),10 \dur,myDurs
);
)
// 2つを一緒に再生します：
(
∼player1 =∼upperMelody .play; 16∼player2 =∼lowerMelody .play; 
)
//それらを個別に停止します：
∼player1.stop;
∼player2.stop;
//その他の利用可能なメッセージ
∼player1.resume;
∼player1.reset; 
∼player1.play;
∼player1.start; // playと同じ。
```

 

**p-38**



  まず、変数の使用に注意してください。その1つであるmyDursはローカル変数です。あなたはそれがローカル変数と見分けることができます。 なぜなら、それはチルダ(∼)で開始されず、先頭で var キーワードで宣言されています。この変数は、両方の Pbind のなかで \durとして使用される全体のPseq を保持します。 myDurs は、スコアを定義する時点でのみ実際に必要となるため、あえてローカル変数を使用することは理にかなっています(ただし、環境変数も問題なく機能します)。この例で見る他の変数は環境変数です。一度宣言されると、それらは SuperCollider パッチのどこでも有効です。

 

 第二に、前述のように、スコアとプレイヤーの分離に注意してください。 Pbind が定義されると、すぐには再生されません。閉じ括弧の直後に .play はありません。



**p-39**



![Pbind counterpoint with a Tchaikovsky melody.PNG](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/82414aed-5b0a-428e-943d-47f0e28cf1e8.png)

図3 pbind Tchaikovsky melodyの対位法：



  最初のコードブロックを評価した後、2つのPbind定義を変数∼upperMelodyおよび∼lowerMelodyに保存するだけです。この２つは、まだ音を出しません。単なるスコアです。∼player1 =∼upperMelody.play の行では、上旋律を演奏するジョブを実行するための EventStreamPlayerを作成して、そのプレーヤーには ∼player1 と命名します。 ∼player2 についても同じ考えです。これにより、各プレーヤーと会話して、停止、開始、再開などを要求できます。

 面倒になる恐れがあるため、最後にもう一度繰り返しましょう。

​	• Pbind は、楽譜のように音を出すための単なるレシピです;

​	• Pbind でメッセージ play を呼び出すと、EventStreamPlayer オブジェクトが作成されます。

​	• この EventStreamPlayer を変数に保存すると、後でアクセスして stop や resume などのコマンドを使用できます。



**p-40**



## Part III

### 言語の詳細

### 16 オブジェクト、クラス、メッセージ、引数

 SuperCollider は、Java や C++ などのオブジェクト指向プログラミング言語です。これが何を意味するのかを説明するのはこのチュートリアルの範囲を超えているので、興味があればウェブ上で検索できるようにします。ここでは、学習しているこの新しい言語をよりよく理解するために知っておく必要があるいくつかの基本的な概念を説明します。 

 SuperColliderのすべてはオブジェクトです。単純な数字でさえ SC のオブジェクトです。異なるオブジェクトは異なる方法で動作し、異なる種類の情報を保持します。オブジェクトにメッセージを送信することにより、オブジェクトから何らかの情報またはアクションを要求できます。 2.squared のようなものを作成すると、メッセージ squared はレシーバーオブジェクト2に送信されます。それらの間のドットは接続を確立します。ところで、メッセージはメソッドとも呼ばれます。

 オブジェクトはクラス内で階層的に指定されます。 SuperCollider には事前定義されたクラスの膨大なコレクションが付属しており、それぞれに独自のメソッドセットがあります。

 これを理解する良い方法があります。 Animal というオブジェクトの抽象クラスがあると想像してみましょう。 Animal クラスは、すべての動物に共通のいくつかの一般的なメソッド(メッセージ)を定義します。年齢、体重、写真などの方法を使用して、動物に関する情報を取得できます。移動、食事、睡眠などの方法は、動物に特定の行動をさせます。それから、Animal の2つのサブクラスを持つことができます。1つは Pet と呼ばれ、もう1つは Wild と呼ばれます。これらのサブクラスのそれぞれには、さらに多くのサブクラスを派生させることができます(Pet から派生した Dog や Cat など)。サブクラスは親クラスからすべてのメソッドを継承し、独自の新しいメソッドを実装して特殊な機能を追加します。たとえば、Dog オブジェクトと Cat オブジェクトの両方が、Animal クラスから継承された .eat メッセージに喜んで応答します。 Dog.name および  Cat.name  は、次の名前を返します。



**p-41**

 

 ペット：このメソッドは、Pet から派生したすべてのオブジェクトに共通です。 Dog には bark メソッドがあるため、Dog.barkを呼び出すと何をすべきかがわかります。 Cat.bark はエラーメッセージをスローします：

```
ERROR: Message ’bark’ not understood.
```

 

 これらすべての仮説例では、大文字で始まる単語はオブジェクトを表すクラスです。ドットの後の小文字の単語は、それらのオブジェクトに送信されるメッセージ(またはメソッド)です。オブジェクトにメッセージを送信すると、常に何らかの情報が返されます。最後に、メッセージは引数を受け入れる(または必要とする)こともあります。引数は、メッセージの直後に括弧で囲まれたものです。Cat.eat( "sardines",2)では、食べるというメッセージと、何を食べるのか、と量という非常に具体的な情報とともに、食べるメッセージが Cat に送信されています。かっこ内で明示的に宣言された引数(コロンで終わるキーワード)が表示される場合があります。これは、議論が何を指しているのかを読者に思い出させるのに便利です。Dog.bark(volume：10)は、単にDog.bark(10)よりも自明です。



![animal.PNG](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/10c60b8f-5118-7075-71a4-7ddc3ecf901b.png)

図4 Hypothetical class hierarchy.



**p-42**



OK-オブジェクト指向プログラミングのこの迅速で汚い説明はこれで十分です。
SuperColliderで実際に実行できる例をいくつか試してみましょう。
1行ずつ実行し、メッセージ、レシーバーオブジェクト、および引数(存在する場合)を識別できるかどうかを確認します。
基本的な構造は、このドキュメントの最後にある Receiver.message(arguments) Answers です。3

```c
12345 [1, 2, 3, "wow"].reverse;
"hello".dup(4);
3.1415.round(0.1); // 最初のドットは3.1415 4 100.randの10進数のケースであることに注意してください。 //この行を数回評価します
// Chaining messages is fun:
100.0.rand.round(0.01).dup(4);
```

### 17 レシーバー表記、ファンクション表記

SuperCollider で式を記述する方法は複数あります。 上記で見たものはレシーバー表記法と呼ばれます：100.rand 、ここでドットはオブジェクト( 100 )をメッセージ( rand )に接続します。 あるいは、まったく同じことを rand( 100 ) のように書くこともできます。 これは関数表記法と呼ばれます。

どちらの記述方法でも使用できます。 メッセージが2つ以上の引数を取る場合の動作を次に示します。

```c
12345.dup(20); // レシーバー表記
dup(5,20); // 関数表記法でも同じこと
3.1415.round(0.1); // レシーバー表記
round(3.1415, 0.1); // 関数表記
```

上記の例では、dup(5,20) を"数値5を20回複製"と読み、round(3.1415,0.1) を"数値3.1415を1桁の小数に丸める"と読みます。逆に、



**p-43**



 レシーバー表記バージョンは、“数値5、20回自分自身を複製します！” ( 5.dup(20) の場合 )および"数値3.1415、小数点以下1桁に丸めます！" ( 3.1415.round(0.1) の場合 )として読み取ることができます。 つまり、Receiver.message(argument) はmessage(Receiver,argument) と同等です。 ある書き方を他の書き方よりも選択することは、個人の好みと慣習の問題です。 あるメソッドが他のメソッドよりも明確な場合があります。 どんなスタイルを好むように(そしてそれらを混ぜても構いません)、重要なことは一貫性を保つことです。 SuperColliderユーザーの間で広まっている慣習の1つは、クラス(大文字で始まる単語)はほぼ常に Receiver.message(argument) として記述されることです。 たとえば、SinOsc.ar(440)は常に表示されますが、ar(SinOsc,440) は両方とも正しいにもかかわらず、ほとんど表示されません。

 演習：関数表記のみを使用して次のステートメントを書き換えます

```c
1100.0.rand.round(0.01).dup(4);
```

回答はこのドキュメントの最後 4

### 18 ネスティング

最後の演習の解決策により、あるものを別のものの中にネストすることができました。 David Cottleは、SuperCollider Bookでネスティングの優れた説明を持っているので、ここで引用します。*

> ネスティングのアイデアをさらに明確にするために、SCが昼食を作る仮想的な例を考えてみましょう。
> そのためには、サーブメッセージを使用します。
> 引数は、サラダ、メインコース、デザートかもしれません。
> ただし、サーブ(レタス、魚、バナナ)と言うだけでは、期待どおりの結果が得られない場合があります。
> したがって、安全にするために、これらの引数を明確にし、それぞれをネストされたメッセージと引数に置き換えることができます。
>
> ```
> serve(toss(lettuce, tomato, cheese), bake(fish, 400, 20), mix(banana, icecream))
> ```

------

*David Cottle “Beginner’s Tutorial.”,SuperCollider Book,MIT Press,2011,pp. 8-9



**p-44**



> SCは、レタス、魚、バナナだけでなく、レタス、トマト、チーズのサラダを提供します。
> 焼き魚; バナナサンデー。
> これらの内部コマンドは、各成分(レタス、トマト、チーズなど)のmessage(arg)をネストすることでさらに明確にすることができます。
> 各内部メッセージは結果を生成し、その結果は外部メッセージの引数として使用されます。

```c
// Pseudo-code to make dinner:
serve(
	toss(
		wash(lettuce, water, 10),
		dice(tomato, small),
		sprinkle(choose([blue, feta, gouda]))
	),
	bake(catch(lagoon, hook, bamboo), 400, 20),
	mix(
		slice(peel(banana), 20),
		cook(mix(milk, sugar, starch), 200, 10)
	)
);
```

>  ネストに複数のレベルがある場合、明確にするために新しい行とインデントを使用できます。 一部のメッセージと引数は1行に残され、一部は1行に1つの引数を付けて展開されます。 各インデントレベルは、ネストのレベルを示す必要があります。 (コードのビット間には、任意の量の空白(改行、タブ、またはスペース)を入れることができます。)
>
>  [夕食の例]ランチプログラムでは、レタスを水で10分間洗浄し、サラダボウルに投げてチーズを振りかける前に、トマトを細かく切るように指示されています。 また、魚を捕まえる場所と、サービングの前に20分間400度で焼く場所などを指定しました。



**p-45**

> このスタイルのコードを"読み取る"には、最も内側のネストされたメッセージから開始し、連続する各レイヤーに移動します。
> 以下は、最も内側のメッセージが外側のメッセージ内にネストされる方法を示すために調整された例です。

```c
			exprand(1.0,1000.0);

		dup({exprand(1.0,1000.0)},100);

	sort(dup({exprand(1.0,1000.0)},100));

round(sort(dup({exprand(1.0,1000.0)},100)),0.01);
```

以下のコードは、ネストの別の例です。
続く質問に答えてください。
数字が何をしているのかを説明する必要はありません。タスクは、ネストの各層で引数を識別することです。
(例と演習の質問もCottleのチュートリアルから借用され、わずかに修正されています。)

```c
// ネストと適切なインデント
(
{
	CombN.ar(
		SinOsc.ar(
			midicps(
				LFNoise1.ar(3, 24,
					LFSaw.ar([5, 5.123], 0, 3, 80)
					)
				),
				0, 0.4
			),
			1, 0.3, 2)
}.play;
)
```



**p-46**



 a) LFNoise1.ar の2番目の引数は何番ですか？

 b) LFSaw.ar の最初の引数は何ですか？

 c) LFNoise1.ar の3番目の引数は何ですか？

 d) midicps にはいくつの引数がありますか？

 e) SinOsc.ar の3番目の引数は何ですか？

 f) CombN.ar の2番目と3番目の引数は何ですか？

 回答については、このドキュメントの最後を参照してください。 5

| ヒント：何らかの理由でコードが適切なインデントを失った場合は、そのすべてを選択してメニューから[編集]→[行または領域の自動インデント]を選択すると修正されます。 |
| ------------------------------------------------------------ |
|                                                              |

### 19 エンクロージャー

 囲いには4つのタイプがあります：(括弧)、[括弧]、{括弧}、および "引用符" 。

 開いたものはそれぞれ、後で閉じる必要があります。 これは"バランス"と呼ばれます。つまり、コード全体で適切に一致するエンクロージャーのペアを維持します。

 SuperCollider IDEは、ペアを閉じると、一致するかっこ (かっことかっこ) を自動的に示します。それらは赤で表示されます。 開始/終了の一致がない括弧をクリックすると、何かが足りないことを示す濃い赤色の選択が表示されます。



**p- 47**



 バランシングは、評価、削除、またはコピー/貼り付け操作のためにコードの大きなセクションを選択する簡単な方法です。 開き括弧または閉じ括弧(括弧と括弧)をダブルクリックして、中のすべてを選択できます。

### 19.1 引用符

 引用符は、一連の文字(スペースを含む)を単一の単位として囲むために使用されます。 これらは文字列と呼ばれます。 一重引用符は、文字列とはわずかに異なるシンボルを作成します。 記号は、テキストの直前にバックスラッシュを付けて作成することもできます。 したがって、"greatSymbol"と\greatSymbolは同等です。

```c
"これは素敵な文字列です"; 

  'greatSymbol';
```

### 19.2 括弧 

  括弧は次の目的で使用できます。

- 引数リストを囲む：rrand(0,10);

- 強制の優先順位：5 	+(10 * 4);

- コードブロックを作成します(一緒に評価される複数行のコード)。 

###  19.3 ブラケット

 角括弧は、[1,2,3,4, "hello"]のようなアイテムのコレクションを定義します。 これらは通常、配列と呼ばれます。 配列には、数字、文字列、関数、パターンなど、何でも含めることができます。



 **p-48**

  

 配列は、リバース、スクランブル、ミラーリング、選択などのメッセージを理解します。配列に対して数学演算を実行することもできます。 

```c
[1,2,3,4, "hello"].scramble;
[1,2,3,4, "hello"].mirror;
[1,2,3,4].reverse + 10;
// midiをHz単位の周波数に変換
[60,62,64,65,67,69,71].midicps.round(0.1);
```

 Arrays の詳細については、セクション22で近日公開予定です。

### 19.4 中括弧

 中括弧(または"中括弧")は関数を定義します。 関数は、おそらく複数回使用および再利用される何らかの種類の操作またはタスクをカプセル化し、そのたびに異なる結果を返す可能性があります。 以下の例は、SuperCollider bookからのものです。

```c
 exprand(1,1000.0);
 {exprand(1,1000.0)}
```

 David Cottleが彼の例を紹介します: "最初の行はランダムな数字を選択します。これはPost ウィンドウに表示されます。 2番目は、まったく異なる結果、つまり関数を出力します。 関数は何をしますか？ 乱数を選択します。 その違いはどのようにコードに影響しますか？ 以下の行を考慮してください。 最初は乱数を選択して複製します。 2番目は乱数抽出関数を5回実行し、結果を配列に収集します。" *

```c
rand(1000.0).dup(5); // 番号を選択して複製します
{rand(1000.0)}.dup(5); // 数字を選ぶ機能を複製します
{rand(1000.0)}.dup(5).round(0.1); // 上記のすべて、そしてラウンド
// 本質的に、これ(同様の結果があります)
[rand(1000.0),rand(1000.0),rand(1000.0),rand(1000.0),rand(1000.0)]
```

------

 *David Cottle "Beginner’s Tutorial." SuperCollider Book,MIT Press,2011,p.13.



**p-49**



 機能についてはもうすぐ。 今のところ、すべての可能なエンクロージャーの概要は次のとおりです。

**コレクション** [list, of, items]

**関数** {しばしば複数行のコード}

**文字列** "引用符内の単語"

**記号** "単一引用符"または\円記号が前に付いている

### 20 条件：if / else および case

 雨が降っている場合は、外出するときに傘をもちます。 晴れている場合は、サングラスをつけます。 私たちの日々は、このような意思決定に満ちています。 プログラミングでは、これらはコードが何らかの条件をテストしなければならない瞬間であり、テストの結果(trueまたはfalse)に応じて異なる一連のアクションを実行する必要があります。 条件構造には多くの種類があります。 if / else と case の2つの単純なものを見てみましょう。

 SCの if / else の構文は、if(condition,{true action},{false action}) です。 条件はブールテストです(trueまたはfalseを返す必要があります)。 テストがtrueを返す場合、最初の関数が評価されます; それ以外の場合、2番目の関数は。試してみてください：

```c
// if / else
if(100> 50,{"非常に真".postln},{"非常に偽".postln});
```



**p-50**



 SuperCollider book *から借用した以下の表は、使用できる一般的なブール演算子を示しています。 単一の等号(x = 10)と2つの等号(x == 10)の違いに注意してください。 シングルサインは"変数xに10を割り当てる"ことを意味し、ダブルサインは"xが10に等しいか"を意味します。trueまたはfalseカラムからいくつかの例を入力して実行すると、実際にtrueまたはfalseの結果が表示されますPost ウィンドウ。



| Symbol    | Meaning                   | True Example        | False Example       |
| --------- | ------------------------- | ------------------- | ------------------- |
| ==        | equal to?                 | 10 == 10            | 10 == 99            |
| != not    | equal to?                 | 10 != 99            | 10 != 10            |
| >         | greater than?             | 10 > 5              | 10 > 99             |
| <         | less than?                | 10 < 99             | 10 < 5              |
| >=        | greater than or equal to? | 10 >= 10, 10 >= 3   | 10 >= 99            |
| <=        | less than or equal to?    | 10 <= 99, 10 <= 10  | 10 <= 9             |
| odd       | is it odd?                | 15.odd              | 16.odd              |
| even      | is it even?               | 22.even             | 21.even             |
| isInteger | is it an integer?         | 3.isInteger         | 3.1415.isInteger    |
| isFloat   | is it a float?            | 3.1415.isFloat      | 3.isFloat           |
| and       | both conditions           | 11.odd.and(12.even) | 11.odd.and(13.even) |
| or        | either condition          | or(1.odd, 1.even)   | or(2.odd, 1.even)   |



 最後の2行(および,または)は、レシーバー表記または関数表記のいずれかで長い式を記述する方法を示しています。

別の有用な構造は、caseです。 テストの1つがtrueを返すまで順番に評価される関数のペアを定義することで機能します。

------

*Cottle, D. “Beginner’s Tutorial.” The SuperCollider Book, MIT Press, 2011, p. 33



**p-51**



Case

{test1} {action1}
{test2} {action2}
{test3} {action3}
. . .
{testN} {actionN};

各テスト内の式は、trueまたはfalseを返す必要があります。
test1 が false を返す場合、プログラムは action1 を無視し、test2 に進みます。
false の場合、action2 も無視され、test3 に進みます。
それが真であることが判明した場合、action3 が実行され、ケースは停止します(それ以上のテストまたはアクションは実行されません)。
関数間にコンマがないことに注意してください。
caseステートメントの終わりを示すために、最後にセミコロン ; を使用するだけです。

```c
// case
(
~num = -2;

case
{~num == 0} {"WOW".postln}
{~num == 1} {"ONE!".postln}
{~num < 0} {"negative number!".postln}
{true} {"last case scenario".postln};
)
```

 上記のコードを変更して、考えられるすべての結果を取得してください。
上記の例のケースの最後の行にある便利な(およびオプションの)トリックに注意してください。trueは常にtrueに評価されるため、前の条件がすべてfalseになった場合に常に発生する"最後のケースシナリオ"アクションを定義できます。
詳細については、制御構造のヘルプファイルをご覧ください。



**p-52**



### 21 関数

 同じタスクを数回実行していることに気付いたら、再利用可能な関数を作成するのがよいかもしれません。 関数は、"エンクロージャー"セクションで学習したように、中括弧内に記述されたものです。 David Touretzkyは、次のように関数の概念を紹介しています。"関数は、データが流れるボックスとして考えてください。 関数は何らかの方法でデータを操作し、その結果が流出します。"*

![function.PNG](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/b8a23923-6036-794c-68d4-ff98b82dfb04.png)

 図5：関数の一般的な考え方。

 以下の例の最初の行は、関数を定義し、それを変数fに割り当てます。 2行目は、関数を機能させます。

```c
f = { 2 + 2 }; // 関数を定義します
2 f.value; // 関数を機能させる
```

上記の関数は、1つのこと(2と2を追加)を行う方法しかわからないため、それほど便利ではありません。
通常は、入力引数に応じて異なる結果が得られる関数を定義します。
キーワード arg を使用して、関数が受け入れることができる入力を指定します。

以下の例は、図5の図面に似ています。

```c
f = {arg a, b; ["a plus b", a+b, "a times b", a*b].postln}; // 関数を定義
f.value(3, 7); // これで、関数の引数として任意の2つの数値を指定できます
f.value(10, 14);

// 比較：
~sillyRand = rrand(0, 10); // 関数ではありません
~sillyRand.value; // 複数回評価
~sillyRand2 = {rrand(0, 10)}; // 関数
~sillyRand2.value; // 数回評価する
```

------

*Touretzky, David. COMMON LISP: A Gentle Introduction to Symbolic Computation. The Benjamin/Cummings
Publishing Company, Inc, 1990, p. 1.
このチュートリアルのタイトルに影響を与えた本です。



**p-53**



最後の例として、非常に便利な関数を1つ示します。

```c
//この関数を使用して、夏の日を過ごす方法を決定します
(
~whatToDo = {
var today, dayName, actions;
	today = Date.getDate.dayOfWeek;
	dayName =
	case
	{today==0} {"Sunday"}
	{today==1} {"Monday"}
	{today==2} {"Tuesday"}
	{today==3} {"Wednesday"}
	{today==4} {"Thursday"}
	{today==5} {"Friday"}
	{today==6} {"Saturday"};
	actions = ["boomerang throwing", "arm wrestling", "stair climbing", "playing
	chess", "underwater hockey", "pea shooting", "a nap marathon"];
	"Ah, " ++ dayName ++ "...! " ++ "What a good day for " ++ actions.choose;
};
)

// 朝に実行する
~whatToDo.value;
```



**ｐ-54**



ヒント：関数の先頭で引数を宣言する別の一般的な表記法は次のとおりです。f={| a,b | a + b}. これは、f = {arg a, b; a + b}と同等です。

### 22 配列の楽しみ

 配列は、SuperColliderで最も一般的なタイプのコレクションです。 [0,1,2]のように、角かっこで囲まれたアイテムのコレクションを記述するたびに、それはArrayクラスのインスタンスになります。 多くの場合、さまざまな方法で配列を操作します。 配列が理解できる興味深いメソッドの一部を以下に示します。

```c
// 配列を作成する
a = [10, 11, 12, 13, 14, 15, 16, 17];

a.reverse; // リバース
a.scramble; // スクランブル
a.choose; // ランダムに1つの要素を選択します
a.size; // 配列のサイズを返します
a.at(0); // 指定された位置のアイテムを取得します
a[0] ; // 同上
a.wrapAt(9); // 指定された位置にあるアイテムを取得し、> a.sizeの場合は折り返します
["wow", 99] ++ a; // 2つの配列を新しいものに連結します
a ++ \hi; // シンボルは単一の文字です
a ++ 'hi'; // シンボルは単一の文字です
a ++ "hi"; // 文字列は文字のコレクションです
a.add(44); // 最後に新しい要素を持つ新しい配列を作成します
a.insert(5, "wow"); // 位置5に"wow"を挿入し、他のアイテムを前方にプッシュします(新しい配列を返します)
a; // これを評価し、上記の操作のどれも実際に元の配列を変更していないことを確認します
a.put(2, "oops"); // インデックス2に "oops"を置きます(destructive;上の行をもう一度評価して確認します)
to check)
a.permute(3); // 位置3のアイテムは位置0に移動し、逆も同様です
a.mirror; // それを回文にします
a.powerset; // 配列の要素のすべての可能な組み合わせを返します
```



**p-55**

配列を使用して数学を行うことができます：

```c
[1, 2, 3, 4, 5] + 10;
[1, 2, 3, 4, 5] * 10;
([1, 2, 3, 4, 5] / 7).round(0.01); // 優先順位の括弧に注意してください
x = 11; y = 12; // いくつかの変数を試します
[x, y, 9] * 100;
// ただし、適切な数値でのみ数学を行うようにしてください
[1, 2, 3, 4, "oops", 11] + 10; // 奇妙な結果
```

### 22.1 新しい配列の作成

 クラスArrayを使用して新しいコレクションを作成するいくつかの方法を次に示します。

```c
// 算術級数 Arithmetic series
Array.series(size: 6, start: 10, step: 3);
// 幾何級数 Geometric series
Array.geom(size: 10, start: 1, grow: 2);
// 2つを比較する：Compare the two:
Array.series(7, 100, -10); // 7アイテム; 100から開始、-10のステップ 7 items; start at 100, step of -10
Array.geom(7, 100, 0.9); // 7アイテム; 100から開始。 毎回0.9倍する 7 items; start at 100; multiply by 0.9 each time
// .fillメソッドを満たす Meet the .fill method
Array.fill(10, "same");
// 比較　Compare:
Array.fill(10, rrand(1, 10));
Array.fill(10, {rrand(1, 10)}); // 関数は10回再評価されます
// .fillメソッドの関数は、カウンターであるデフォルトの引数を取ることができます。 The function for the .fill method can take a default argument that is a counter.
// 引数名は何でも構いません。The argument name can be whatever you want.
Array.fill(10, {arg counter; counter * 10});
// たとえば、高調波周波数のリストを生成します：For example, generating a list of harmonic frequencies:
Array.fill(10, {arg wow; wow+1 * 440});
// .newClearメソッド The .newClear method
a = Array.newClear(7); // creates an empty array of given size
a[3] = "wow"; // a.put(3, "wow")と同じ

```



**p-56**



### 22.2 その面白い感嘆符

他の人のコードに30！4のようなものが表示されるのは時間の問題です。 このショートカット表記は、同じアイテムを含む配列を何度も作成するだけです。

```c
// ショートカット表記 :
30!4;
"hello" ! 10;
// 以下と同じ結果が得られます:
30.dup(4);
"hello".dup(10);
// または
Array.fill(4, 30);
Array.fill(10, "hello");
```

### 22.3 括弧の間の2つの点

  配列の作成に使用されるもう1つの一般的な構文のショートカットを次に示します。

```c
// What is this?
(50..79);

// 算術級数の配列を生成するショートカットです It's a shortcut to generate an array with an arithmetic series of numbers.
// 上記の結果は次と同じです:
series(50, 51, 79);
// or
Array.series(30, 50, 1);
// 1以外のステップの場合、これを行うことができます:
(50, 53 .. 79); // step of 3
// Same result as:
series(50, 53, 79);
Array.series(10, 50, 3);
```



**p-57**



 各コマンドは、わずかに異なる考え方を暗示していることに注意してください。 (50..79)を使用すると、"50∼79の配列を指定してください"というように考えることができます。配列に含まれるアイテムの数を必ずしも考慮する必要はありません。 一方、Array.seriesを使用すると、"合計で30個のアイテムを含む配列を50個からカウントアップしてください"と考えることができます。シリーズの最後の番号が誰になるかを必ずしも考える必要はありません。

 また、ショートカットでは角括弧ではなく括弧が使用されることに注意してください。 もちろん、結果の配列は角括弧で囲まれます。

### 22.4 配列を"do"する方法

 多くの場合、コレクションのすべてのアイテムに対して何らかのアクションを実行する必要があります。 これにはメソッドdoを使用できます。

 

```c
~myFreqs = Array.fill(10, {rrand(440, 880)});

// ここで、リストのすべての項目で簡単なアクションを実行しましょう Now let's do some simple action on every item of the list:
~myFreqs.do({arg item, count; ("Item " ++ count ++ " is " ++ item ++ " Hz. Closest
midinote is " ++ item.cpsmidi.round).postln});

// カウンターが必要ない場合は、1つの引数を使用します： If you don't need the counter, just use one argument:
~myFreqs.do({arg item; {SinOsc.ar(item, 0, 0.1)}.play});
~myFreqs.do({arg item; item.squared.postln});

// もちろん、次のように最後の1つと同じくらい簡単なことができます Of course something as simple as the last one could be done like this:
~myFreqs.squared;
```



**p-58**



 要約すると、配列を"do"すると、関数が提供されます。 メッセージdoは、配列のアイテムを繰り返し処理し、その関数を毎回評価します。 この関数は、デフォルトで2つの引数を取ることができます。現在の反復での配列項目と、反復回数を追跡するカウンターです。 これらの引数の名前は好きなものにすることができますが、それらは常にこの順序です: item, count.

 メソッドcollect も参照してください。これは、do と非常に似ていますが、すべての中間結果を含む新しいコレクションを返します。

### 23 困ったときは

 ヘルプファイルを活用する方法を学びます。 多くの場合、各ヘルプページの下部に役立つ例があります。 最初にテキストの説明を完全に理解していない場合でも、(または特別に)下にスクロールしてチェックアウトしてください。 ヘルプブラウザーからサンプルを直接実行するか、コードをコピーして新しいウィンドウに貼り付けて再生することができます。

 SuperCollider コードで有効なクラスまたはメソッドを選択し(単語をダブルクリックして選択します)、[ctrl + D]を押して対応するヘルプファイルを開きます。 クラス名(たとえば、MouseX)を選択すると、クラスのヘルプファイルが表示されます。 メソッドを選択すると、そのメソッドを理解するクラスのリストが表示されます(たとえば、メソッド scramble のヘルプを表示させます)。*  

------

 *注意：SuperColliderは大文字で始まる単語を青色で表示します。 これは、



**p-59**



 SuperCollider IDEでヘルプファイルを探索する他の方法は、"Browse" および "Search" リンクです。 [Browse]を使用してファイルをカテゴリ別に移動し、[Search] を使用してすべてのヘルプファイル内の単語を検索します。 SuperCollider IDEのヘルプブラウザに関する重要な注意：

- 右上のフィールド(“Find...”と表示)を使用して、現在開いているヘルプファイル内の特定の単語を検索します(Webサイトで"検索"を実行する場合など)。

- [Search]リンク(“Browse”の右側)を使用して、すべてのヘルプファイルでテキストを検索します。

 最初に括弧を開いて特定のメソッドに引数を追加すると、SCは小さな"ツールヒントヘルプ"を表示して、予想される引数が何であるかを示します。 たとえば、図6に表示される行の先頭を入力します。最初のかっこを開いた直後に、SinOsc.arの引数がfreq,phase,mul, および add であることを示すツールチップが表示されます。 また、デフォルト値が何であるかを示しています。 これは、SinOscヘルプファイルから取得する情報とまったく同じです。 ツールチップが消えた場合は、[ctrl + Shift + Space] で元に戻すことができます。 

![1570289368565.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/d222e51b-79dc-1ce1-50f3-60063ddfb892.png)

図6：入力すると役立つ情報が表示されます 

別のショートカット：引数に明示的に名前を付けたい場合 ( SinOsc.ar(freq：890) など )、括弧を開いた直後にタブキーを押してみてください。 SCは入力時に正しい引数名を順番に入力します(後続の引数名のコンマの後にタブを押します)。

------

color blue は、単語にタイプミスがないことを保証するものではありません。たとえば、Sinosc (小文字の "o"を間違えた) を入力すると、青色で表示されます。



**p-60**

 

| ヒント：独自の"パーソナライズされたヘルプファイル"を含むフォルダーを作成します。新しいトリックを見つけたり、新しいオブジェクトを学習したりするときは、自分の言葉で説明した簡単な例を書き、将来のために保存します。 今から1か月または1年後に便利になるかもしれません。 |
| ------------------------------------------------------------ |
|                                                              |

 まったく同じヘルプファイルは、オンラインで見つけることもできます。 http：//doc.sccode.org/



**p-61**



## Part IV

### 音声合成と処理



 この時点で、SuperColliderについてすでに多くのことを知っています。 このチュートリアルの最後の部分では、変数からエンクロージャーまで、言語自体についての詳細を紹介しました。 また、パターンファミリのいくつかのメンバーを使用して、興味深いPbind を作成する方法も学びました。

 チュートリアルのこの部分では、(最終的には！)SuperColliderを使用したサウンドの合成と処理について説明します。 ユニットジェネレーター( UGens )のトピックから始めます。 *

### 24 UGens

セクション3およびセクション18で、いくつかのユニットジェネレーター( UGens )が動作しているのを既に見てきました。 ユニットジェネレーターは、音声信号または制御信号を生成するオブジェクトです。
これらの信号は常にサーバーで計算されます。
ユニットジェネレータには多くのクラスがあり、それらはすべて UGen クラスから派生しています。
SinOsc と LFNoise0 は UGen の例です。
詳細については、"Unit Generators and Synths" および "Tour of UGens" というヘルプファイルをご覧ください。

このチュートリアルの前半で Pbinds をプレイしたとき、デフォルトのサウンドは常に同じで、シンプルなピアノのようなシンセです。
そのシンセはユニットジェネレーターの組み合わせで作られています。
†学習します。

------

*ほとんどのチュートリアルは、すぐにユニットジェネレーターから始まります。ただし、SCのこのイントロでは、異なる教育学的アプローチのために、最初にパターンファミリー( Pbind と友人)を強調することを選択しました。
†これまでは、Pbinds を使用してSuperColliderでサウンドを作成していたため、"そうだ、Pbind はユニットジェネレーターだ！"とは思わないかもしれません。
Pbind はユニットジェネレータではなく、音楽イベント(スコア)を作成するための単なるレシピです。
"だから、EventStreamPlayer、Pbind で play を呼び出したときに生じるもの、それは UGen でなければならない！" という答えはまだノーです。
EventStreamPlayer は、ピアニストのような単なるプレーヤーであり、ユニットジェネレータを組み合わせて、あらゆる種類の電子楽器を合成音と処理音で作成する方法です。
次の例は、最初の正弦波から作成して、マウスでライブ演奏できる電子楽器を作成します。



**p-62**



### 24.1 マウス制御：インスタントテルミン

ライブで演奏できるシンプルなシンセをご紹介します。 これは、最も古い電子楽器の1つであるテルミンのシミュレーションです。

```c
{SinOsc.ar(freq: MouseX.kr(300, 2500), mul: MouseY.kr(0, 1)}.play;
```

テルミンとは何かわからない場合は、今すぐすべてを停止し、YouTubeで“Clara Rockmore Theremin”を検索してください。 その後、ここに戻って、SCテルミンで白鳥の歌を演奏してみてください。

SinOsc、MouseX、および MouseY は UGen です。SinOsc は正弦波トーンを生成しています。
他の2つは、画面上のカーソルの動き(水平方向の動きはX、垂直方向の動きはY)をキャプチャし、数値を使用して周波数と振幅値を正弦波に送ります。
非常にシンプルで、とても楽しいです。

### 24.2 のこぎりとパルス。プロットとスコープ。

 上記のテルミンは正弦波発振器を使用しました。 サウンドを作成するために使用できる他の波形があります。 以下の行を実行します(便利なプロット方法を使用します) SinOsc の形を見て、Saw と Pulse と比較します。 以下の行は音を出しません。波形のスナップショットを視覚化するだけです。

------

 ピアニストは音を出しません。 この限られた metaphor に沿って、楽器のピアノは実際に振動して音を生成します。 これは UGen のより適切な例えです。スコアでもプレイヤーでもありません。楽器です。 以前に Pbinds で音楽を作成した場合、SCは  EventStreamPlayer を作成して、組み込みのピアノシンセでスコアを再生します。 ピアノの作成などを心配する必要はありませんでした。SuperColliderはすべての作業をボンネットの下で行ってくれました。 その隠されたピアノシンセは、いくつかのユニットジェネレーターの組み合わせで作られています。



**p-63**



```c
{ SinOsc.ar }.plot; // 正弦波 sine wave
{ Saw.ar }.plot; // のこぎり波 sawtooth wave
{ Pulse.ar }.plot; // 方形波 square wave
```

次に、SinOsc を Saw に、次に Pulse に置き換えて、テルミンの行を書き換えます。 音の違いを聞いてください。 最後に、テルミンコードで .play の代わりに .scope を試すと、リアルタイムで波形の表現を見ることができます("Stethoscope"ウィンドウがポップアップ表示されます)。

### 25 音声レート、制御レート

 SuperCollider コードで UGen を見つけるのは非常に簡単です。ほとんどの場合、メッセージの後に .ar または .kr のメッセージが続きます。 これらの文字は、オーディオレートとコントロールレートを表しています。 これが何を意味するのか見てみましょう。

 "Unit Generators and Synths" ヘルプファイルから：

>  ユニットジェネレーターは、arまたはkrメッセージをユニットジェネレーターのクラスオブジェクトに送信することによって作成されます。 arメッセージは、オーディオレートで実行されるユニットジェネレーターを作成します。 krメッセージは、制御レートで実行されるユニットジェネレーターを作成します。 制御レートユニットジェネレーターは、低周波数またはゆっくり変化する制御信号に使用されます。 コントロール レートユニット ジェネレーターは、制御サイクルごとに1つのサンプルのみを生成するため、オーディオレートユニットジェネレーターよりも処理能力が低くなります。 *

 つまり、SinOsc.ar を作成すると、"オーディオレート"というメッセージが SinOsc UGen に送信されます。 コンピューターが44100 Hzの一般的なサンプリングレートで実行されていると仮定すると、この正弦発振器は、1秒あたり44100サンプルを生成して、スピーカーに送信します。
次に、正弦波が聞こえます。

 今読んだものについてもう一度考えてみてください。ar メッセージを UGen に送信すると、毎秒4万4千個の数字を生成するように指示しています。
それはたくさんの数字です。 {SinOsc.ar}.play を言語で記述し、言語がリクエストをサーバーに伝えます。
これらすべてのサンプルを生成する実際の作業は、サーバー、SuperColliderの"サウンドエンジン"によって行われます。

------

*[http://doc.sccode.org/Guides/UGens-and-Synths.html](https://translate.googleusercontent.com/translate_c?depth=1&hl=ja&rurl=translate.google.com&sl=en&sp=nmt4&tl=ja&u=https://www.google.com/url%3Fq%3Dhttp://doc.sccode.org/Guides/UGens-and-Synths.html%26sa%3DD%26ust%3D1568980532131000&xid=17259,1500003,15700021,15700186,15700191,15700256,15700259,15700262,15700265&usg=ALkJrhh67bsixF7W6n5catx2_rbJaiT7IQ)



**p-64**



 現在、 ar の代わりに kr を使用すると、ジョブもサーバーによって実行されますが、いくつかの違いがあります。

1. .krで生成される1秒あたりの数値の量ははるかに少なくなります。 {SinOsc.ar} .playは毎秒44100の数値を生成しますが、{SinOsc.kr} .playは毎秒700未満の数値を出力します(興味がある場合、正確な量は44100/64です。64はいわゆる"control period."。)

2. krで生成された信号はスピーカーに送られません。 代わりに、通常、他の信号のパラメーターを制御するために使用されます。たとえば、テルミンの MouseX.kr が SinOsc の周波数を制御していました。

 OK、それで UGen はこれらの非常に高速な数値のジェネレータです。 これらの数値の一部は音声信号になります。 その他は制御信号になります。 ここまでは順調ですね。 しかし、結局のところ、これらの数字は何ですか？ 大きい？ 小さい？ ポジティブ？ 負？ 多くの場合、-1から+1の間、時には0から1の間の非常に小さい数値であることがわかります。すべての UGen は、生成する数値の範囲に従って、ユニポーラ UGenとバイポーラ UGenの2つのカテゴリに分類できます。

 **ユニポーラ UGen**は、0∼1の数値を生成します。

 **バイポーラ UGen**は、-1∼+1の数値を生成します。



 **p-65**



### 25.1 pollメソッド

 一部の UGen の出力を覗き見ると、これがより明確になります。 SuperColliderがPostウィンドウに毎秒数千の数字を印刷することは期待できませんが、毎秒数個を印刷するように依頼することはできます。 次の行を一度に1つずつ入力して実行し(サーバーが実行されていることを確認してください)、Postウィンドウを監視します。

```c
1 // just watch the Post window (no sound)
2 {SinOsc.kr(1).poll}.play;
3 // hit ctrl+period, then evaluate the next line:
4 {LFPulse.kr(1).poll}.play;
```

  例ではkrを使用しているため音が出ません。結果は制御信号であるため、スピーカーには何も送信されません。 ここでのポイントは、SinOsc の典型的な出力を見るだけです。 メッセージポーリングは、SinOsc 出力から1秒あたり10個の数字を取得し、それらをPostウィンドウに出力します。 引数1は周波数で、サインを意味します。

 サイクル全体を完了するには1秒かかります。 あなたが観察したことに基づいて、SinOsc は単極ですか、双極ですか？ LFPulse はどうですか？6

次の行を評価する前にボリュームを下げてから、ゆっくりと戻します。
柔らかいクリック音が聞こえるはずです。

```c
{LFNoise0.ar(1).poll}.play;
```

 メッセージ ar を送信したため、この低周波ノイズジェネレーターは、サウンドカードに毎秒44100サンプルを出力しています。これはオーディオ信号です。 各サンプルは-1∼+1の数値です(したがって、バイポーラ UGen です)。 投票では、1秒あたり10件しか表示されません。LFNoise0.ar(1) は、毎秒新しい乱数を選択します。これらはすべてサーバーによって実行されます。[ctrl +.]でクリックを停止し、LFNoise0 の周波数を変更してみてください。3、5、10などの数字を試してください。出力番号を見て、結果を聞きます。



**p-66**



### 26 UGen 引数

ほとんどの場合、使用している UGen の引数を指定する必要があります。あなたはすでにそれを見ました：{SinOsc.ar(440)}.play を書くとき、数字440は SinOsc.ar の引数です。聞こえる周波数を指定します。 {SinOsc.ar(freq：440、mul：0.5)}.play のように、引数の名前を明示することができます。引数名は freq および mul です(コード内の単語の直後のコロンに注意してください)。  mul は"乗数"の略で、基本的には波形の振幅です。 mul を指定しない場合、SuperColliderはデフォルト値の1(最大振幅)を使用します。 mul の使用：0.5は、波形を半分に乗算することを意味します。つまり、最大振幅の半分で再生します。テルミンコードでは、SinOsc の引数 freq および mul に明示的に名前が付けられています。 MouseX.kr(300、2500)  は、テルミンの周波数をコントロールするために使用されました。 MouseX.kr は、出力範囲の下限と上限の2つの引数を取ります。それが、数字300と2500がそこで行っていたことです。振幅を制御する MouseY.kr(0、1) についても同じです。マウス UGen 内の引数には明示的な名前は付けられませんでしたが、そうすることはできます。

UGen がどのような引数を受け入れるかをどのようにして見つけますか？対応するヘルプファイルに移動します：UGen 名をダブルクリックして選択し、[ctrl + D]を押してドキュメントページを開きます。たとえば、MouseX でこれを行います。 [説明]セクションの後に、[クラスメソッド]セクションが表示されます。そこには、kr メソッドの引数が minval、maxval、warp、および lag であると書かれています。同じページから、それぞれの機能を確認できます。

引数を指定しない場合、SCはヘルプファイルに表示されるデフォルト値を使用します。引数に明示的に名前を付けない場合は、ヘルプファイルに示されている正確な順序で引数を指定する必要があります。明示的に名前を付けた場合は、任意の順序で並べることができ、途中でスキップすることもできます。引数を明示的に命名することも、コードをよりよく理解するのに役立つため、優れた学習ツールです。以下に例を示します。

```c
// minvalとmaxvalが順番に提供され、キーワードなし minval and maxval provided in order, no keywords
{MouseX.kr(300, 2500).poll}.play;
// minval,maxval,およびlagが提供され、ワープをスキップ minval, maxval and lag provided, skipped warp
{MouseX.kr(minval: 300, maxval: 2500, lag: 10).poll}.play;
```



**p-67**



### 27 スケーリング範囲

 実際の楽しみは、いくつかの UGen を使用して他の UGen のパラメーターを制御するときに始まります。テルミンの例はまさにそれを行いました。：今、あなたはセクション3の例のひとつを正確に理解するためのすべてのツールを持っています。例の中で最後の3行はステップバイステップで、どのようにして LFNoise0 で周波数を制御するか方法を示します。

```c
{SinOsc.ar(freq: LFNoise0.kr(10).range(500, 1500), mul: 0.1)}.play;

// 分解する Breaking it down:
{LFNoise0.kr(1).poll}.play; // シンプルなLFNoise0の動作を見ます watch a simple LFNoise0 in action
{LFNoise0.kr(1).range(500, 1500).poll}.play; // .rangeがあります now with .range
{LFNoise0.kr(10).range(500, 1500).poll}.play; // now faster
```

### 27.1 スケールとrangeメソッド

 range メソッドは、単に UGen の出力を再スケーリングします。 LFNoise0 は-1から+1までの数を生成することを覚えておいてください(バイポーラ UGenです)。これらの生の数値は、周波数を制御するのにあまり有用ではありません(人間の聴力範囲内で適切な数値が必要です)。 .range は-1と+1の間の出力を受け取り、引数として指定した低い値と高い値(この場合は500と1500)に合わせてスケーリングします。 LFNoise0.kr の引数である数値10は、UGen の頻度、つまり1秒あたり何回新しい乱数を選択するかを指定します。



**p-68**



 要するに、UGen を使用して別の UGen のパラメーターを制御するには、まず、必要な数値の範囲を知る必要があります。数値は周波数になりますか？たとえば、100∼1000の範囲でそれらを使用しますか？それとも振幅ですか？おそらく、振幅を0.1(ソフト)から0.5(最大の半分)にしたいでしょうか？または、高調波の数を制御しようとしていますか？ 5から19の間にしたいですか？

 必要な範囲がわかったら、.range メソッドを使用して、制御する UGen に正しい動作をさせます。

 演習：周波数が LFPulse.kr によって制御される正弦波を再生する単純なラインコードを記述します(適切な引数を提供します)。次に、.range メソッドを使用して、LFPulse の出力を聞きたいものにスケーリングします。

### 27.2 MULを使用したスケーリングと追加

 これで、.rangeメソッドを使用して、サーバーで UGen の出力をスケーリングする方法がわかりました。ほぼすべての UGen が持っている引数 mul およびaddを使用することにより、同じことをより基本的なレベルで実現できます。以下のコードは、バイポーラ UGen とユニポーラ UGen の両方で、範囲アプローチと mul / add アプローチの等価性を示しています。

```c
// This:
{SinOsc.kr(1).range(100, 200).poll}.play;
// ...is the same as this:
{SinOsc.kr(1, mul: 50, add: 150).poll}.play;

// This:
{LFPulse.kr(1).range(100, 200).poll}.play;
// ...is the same as this:
{LFPulse.kr(1, mul: 50, add: 100).poll}.play;

```



**p-69**



図7は、UGen 出力の再スケーリングにおける mul およびaddの動作を視覚化するのに役立ちます(SinOsc がデモとして使用されます)。

![Scaling UGen ranges.PNG](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/952fb4e4-90c1-200f-8d64-aed50dbbf2ca.png)

図7: Scaling UGen ranges with mul and add

### 27.3 linlin and friends

その他の任意のスケーリングには、便利なメソッド linlin、linexp、explin、expexp を使用できます。メソッド名は、それらが何をするかのヒントを示します。線形範囲を別の線形範囲に変換( linlin )、線形から指数に変換( linexp )など。



**p-70**



```c
// A bunch of numbers
a = [1, 2, 3, 4, 5, 6, 7];
// 0から127に再スケーリング、線形から線形
a.linlin(1, 7, 0, 127).round(1);
// 0から127、線形から指数
a.linexp(1, 7, 0.01, 127).round(1); // 指数範囲にゼロを使用しないでください
```

### 28 個々のシンセを停止する

 これは、いくつかのシンセを開始し、それらを個別に停止できる非常に一般的な方法です。例は自明です：

```c
// 一度に1行ずつ実行します(間に音を止めないでください)：
a = { Saw.ar(LFNoise2.kr(8).range(1000, 2000), mul: 0.2) }.play;
b = { Saw.ar(LFNoise2.kr(7).range(100, 1000), mul: 0.2) }.play;
c = { Saw.ar(LFNoise0.kr(15).range(2000, 3000), mul: 0.1) }.play;
// シンセを個別に停止する：
a.free;
b.free;
c.free;
```

### 29 設定メッセージ

 他の関数(レビューセクション21)と同様に、シンセ関数の先頭で指定された引数にはユーザーがアクセスできます。これにより、シンセのパラメーターをオンザフライで変更できます(シンセの実行中)。そのためにメッセージセットが使用されます。簡単な例：



**p-71**



```c
x = {arg freq = 440, amp = 0.1; SinOsc.ar(freq, 0, amp)}.play;
x.set(\freq, 778);
x.set(\amp, 0.5);
x.set(\freq, 920, \amp, 0.2);
x.free;
```

デフォルト値(上記の440や0.1など)を指定することをお勧めします。そうしないと、"空の"パラメーターに適切な値を設定するまでシンセが再生されません。

### 30 オーディオバス

 オーディオバスは、オーディオ信号のルーティングに使用されます。それらはミキシングボードのチャンネルのようなものです。 SuperColliderにはデフォルトで128個のオーディオバスがあります。制御バスもあります(制御信号用)が、ここではオーディオバスのみに注目しましょう。*

[ctrl + M]を押して、メーターウィンドウを開きます。 すべての入力および出力のレベルが表示されます。 図8は、このウィンドウのスクリーンショットとSuperColliderのデフォルトバスへの対応を示しています。 SuperColliderでは、オーディオバスには0〜127の番号が付けられます。最初の8つ（0〜7）は、デフォルトでサウンドカードの出力チャンネルとして予約されています。 次の8つ（8〜15）は、サウンドカードの入力用に予約されています。 他のすべて（16〜127）は、オーディオ信号をある UGen から別の UGen にルーティングする必要がある場合など、任意の方法で自由に使用できます。

### 30.1 Out and In UGens

次のコードを試してください:

```c
{Out.ar(1, SinOsc.ar(440, 0, 0.1))}.play; // right channel
```
------

*セクション41で制御バスを簡単に見ていきます。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225786/b013c653-bad1-9b5d-1f57-6289199cacc5.png)

図8：SCのオーディオ bus とメーターウィンドウ



**p-73**



 Out UGen は、特定の bus への信号のルーティングを処理します。
 Out の最初の引数は、ターゲット bus、つまり、この信号の送信先です。 上記の例では、番号1は、サウンドカードの正しいチャネルである bus 1に信号を送信することを意味します。
 Out.ar の2番目の引数は、そのバスに「書き込む」実際の信号です。
単一の UGen、または UGen の組み合わせにすることができます。 例では、これは単なる正弦波です。 右のスピーカー（またはヘッドフォンを使用している場合は右の耳）でのみ聞こえます。
メーターウィンドウを開いて表示した状態で、Out.ar の最初の引数を変更します。
0から7までの数字を試して、メーターを見てください。 指示した場所に信号が送られることがわかります。

| ヒント：ほとんどの場合、2つのチャンネル（左右）しか再生できないサウンドカードがあるため、サイントーンは bus 0 または bus 1 に送信したときにのみ聞こえます。他の bus に送信すると（3〜 7）、対応するメーターに信号が表示されます：SCは実際にその bus にサウンドを送信していますが、8チャンネルのサウンドカードがない限り、bus 3〜7の出力を聞くことはできません。 |
| ------------------------------------------------------------ |
|                                                              |

エフェクトに使用されるオーディオ bus の簡単な例を以下に示します。

```c
// start the effect
f = {Out.ar(0, BPF.ar(in: In.ar(55), freq: MouseY.kr(1000, 5000), rq: 0.1))}.play;
// start the source
n = {Out.ar(55, WhiteNoise.ar(0.5))}.play;
```

最初の行は、フィルター UGen（バンドパスフィルター）で構成されるシンセ（変数fに格納）を宣言します。バンドパスフィルターは、入力として任意のサウンドを受け取り、通過させたい1つの周波数領域を除くすべての周波数をフィルター処理します。 In.ar は、オーディオバスからの読み取りに使用する UGen です。したがって、BPF の入力として In.ar（55） が使用されると、バス55に送信するサウンドはすべてバンドパスフィルターに渡されます。
この最初のシンセは最初は何も音を立てないことに注意してください: 最初のラインを評価しても、バス55はまだ空です。bus 55 にオーディオを送信するときにのみ音がします。これは2行目で発生します。

2行目はシンセを作成し、変数nに保存します。このシンセは、単にホワイトノイズを生成し、スピーカーに直接出力するのではなく、代わりにオーディオ bus 55に出力します。これがまさにフィルターシンセがリッスンしている bus なので、2行目を評価するとすぐに、シンセ f によってフィルター処理されているホワイトノイズが聞こえ始めます。要するに、ルーティングは次のようになります。

noise synth→ bus 55→ filter synth

実行の順序は重要です。効果の前にソースを評価する場合、前の例は機能しません。これについては、セクション42"実行の順序"で詳しく説明します。最後の1つ：{SinOsc.ar(440)}.play のような以前のサンプルシンセで書いたとき、SCは実際に {Out.ar(0,SinOsc.ar(440))}.play の下で：bus 0にサウンドを送信することを想定していたため、最初の UGen を自動的に Out.ar(0,...)UGen でラップしました。実際、舞台裏でさらにいくつかのことが行われていますが、これについては後で説明します(セクション39)。

### 31 マイク入力

 下の例は、SoundIn UGen を使用してサウンドカードからサウンド入力に簡単にアクセスする方法を示しています。 *

------

*In.ar は任意の bus から読み取り、サウンドカード入力はデフォルトで bus 8∼15に割り当てられていることがわかっているため、In.ar(8) を書き込んでマイクからサウンドを取得できます。それはうまく機能しますが、SoundIn.ar はより便利なオプションです。



**p-75**



```c
// 警告：フィードバックを避けるためにヘッドフォンを使用してください
{SoundIn.ar(0)}.play; // In.ar(8)と同じ：最初の入力バスからサウンドを取得

// Stereo version
{SoundIn.ar([0, 1])}.play; // 1番目と2番目の入力
// Some reverb just for fun?
{FreeVerb.ar(SoundIn.ar([0, 1]), mix: 0.5, room: 0.9)}.play;
```

### 32 マルチチャンネル拡張

 メーターウィンドウが開いている状態で—[ctrl + M]—、これを見てください。

```c
{Out.ar(0, Saw.ar(freq: [440, 570], mul: Line.kr(0, 1, 10)))}.play;
```

 素晴らしい Line.kr UGen を使用して、振幅を10秒で0から1に増加させています。それはきちんとしている。しかし、ここではさらに興味深い魔法が起こっています。 2つの出力チャネル(左と右)があることに気づきましたか？各チャンネルに異なる音があることを聞きましたか？そして、これらの2つの音符はリストから得られます— [440,570] —それは周波数引数として Saw.ar に渡されますか？

 これはマルチチャネル拡張と呼ばれます。

David Cottleは、"マルチチャネル拡張はブードゥー教に隣接する[ 配列のapplication ]である" *と冗談を言います。これは、SuperColliderの最も強力でユニークな機能の1つであり、最初は人々を困惑させる可能性があります。
簡単に言うと、どこでも UGen の引数の1つとして配列を使用すると、パッチ全体が複製されます。 作成されるコピーの数は、配列内のアイテムの数です。
これらの複製された UGen は、Out.ar の最初の引数として指定された bus から開始して、必要な数の隣接 bus に送信されます。

------

*Cottle, D. “Beginner’s Tutorial.” The SuperCollider Book, MIT Press, 2011, p. 14



**p-76**



 上記の例では、Out.ar(0,...) があります。のこぎり波の周波数は、[440,570] の2つの項目の配列です。 SCは何をしますか？ "マルチチャネル拡張"により、パッチ全体のコピーが2つ作成されます。最初のコピーは、周波数440 Hzのノコギリ波で、バス0(左チャンネル)に送信されます。 2番目のコピーは、周波数570 Hzのノコギリ波で、バス1(右チャンネル)に送信されます！

 さあ、自分で確認してください。これらの2つの周波数を任意の他の値に変更します。結果を聞いてください。 1つは左チャンネルに行き、もう1つは右チャンネルに行きます。さらに進んで、リストに3番目の頻度を追加します( [440,570,980] など)。メーターウィンドウを確認します。最初の3つの出力が点灯していることがわかります(ただし、マルチチャンネルサウンドカードを持っている場合のみ、3番目の出力を聞くことができます)。

 さらに、同じ UGen の他の引数、または同じシンセの他の UGen の引数で追加の配列を使用できます。 SuperColliderはハウスキーピングを行い、それに応じてこれらの値に従うシンセを生成します。たとえば、現在、両方の周波数[440,570] は10秒で0から1にフェードインしています。ただし、コードを Line.kr(0,1,[1,15]) に変更すると、440 Hzトーンがフェードインするのに1秒かかり、570 Hzトーンがフェードインするのに15秒かかります。試してみてください。

 演習：古い電話の"ビジートーン"のシミュレーションを聞いてください。マルチチャンネル拡張を使用して、それぞれが異なるチャンネルで異なる周波数を再生する2つの正弦オシレーターを作成します。

 左チャネルパルスを1秒間に2回、右チャネルパルスを1秒間に3回にします。 7

```c
a = {Out.ar(0, SinOsc.ar(freq: [800, 880], mul: LFPulse.ar(2)))}.play;
a.free;
```



**p-77**



### 33 The Busオブジェクト

 前の2つのセクションで学んだすべてを使用する例は次のとおりです。オーディオバスとマルチチャネル拡張。

```c
// これを最初に実行します("リバーブをオンにする"--最初は何も聞こえません)
r = {Out.ar(0, FreeVerb.ar(In.ar(55, 2), mix: 0.5, room: 0.9, mul: 0.4))}.play;

// ここでこの2番目を実行します("ビジートーンをリバーブバスにfeedする")
a = {Out.ar(55, SinOsc.ar([800, 880], mul: LFPulse.ar(2)))}.play;
a.free;
```

 マルチチャネル拡張のおかげで、ビジートーンは2つのチャネルを使用します。
(シンセaで)ビジートーンを bus 55 にルーティングすると、2つの bus が実際に使い果たされます。bus 55 と、すぐ隣の bus 56 です。reverb (synth r) では、In.ar(55, 2) で bus 55 から始まる2つのチャンネルを読み取りたい場合：55と56の両方が reverb に入ります。reverb の出力も2つのチャンネルに拡張されるため、synth r はbus 0と bus 1 (サウンドカードの左右のチャンネル)にサウンドを送信します。

 今、ソースシンセをエフェクトシンセに接続するための bus 番号(55)の選択は任意でした: 16から127の間の他の番号でもかまいません( bus 0 から15はサウンドカードの出力と入力のために予約されています)。

バス番号を自分でトラッキングしなければならないとしたら、どれほど不便でしょう。パッチが複雑になったらすぐに、悪夢を想像してください。"リバーブ用に再度選択した bus 番号は？59または95でしたか？遅延の bus 番号はどうですか？27だったと思う？思い出せない..." などなど。

SuperColliderは、Busオブジェクトを使用してこれを処理します。上記の例では、デモンストレーションのために悪名高い bus 55 のみを手動で割り当てました。
SuperColliderの日常生活では、シンプルに Bus オブジェクトを使用するべきです。
Bus オブジェクトは、常に使用可能な bus を選択して作業を行います。これがあなたの使い方です：



**p-78**



```c
// バスを作成
~myBus = Bus.audio(s, 2);
// リバーブをオンにする：myBus(ソースサウンド)から読み取ります
r = {Out.ar(0, FreeVerb.ar(In.ar(~myBus, 2), mix: 0.5, room: 0.9, mul: 0.4))}.play;
// ビジートーンを∼myBusにフィード Feed the busy tone into ~myBus
b = {Out.ar(~myBus, SinOsc.ar([800, 880], mul: LFPulse.ar(2)))}.play;
// 両方のシンセを解放 Free both synths
r.free; b.free;
```

 Bus.audio の最初の引数は、サーバーを表す変数sです。 2番目の引数は、必要なチャネルの数です(例では2)。次に、それを意味のある名前の変数に入れます(例では∼myBus ですが、∼reverbBus、∼source、∼tangerine、またはパッチで意味のあるもの)。その後、そのバスを参照する必要があるときはいつでも、作成した変数を使用します。

### 34 パンニング

 パンニングとは、オーディオ信号をステレオまたはマルチチャンネルの音場に広げることです。以下は、Pan2 によって左右のチャンネル間で跳ね返るモノ信号です。*

```c
p = {Pan2.ar(in: PinkNoise.ar, pos: SinOsc.kr(2), level: 0.1)}.play;
p.free;
```

Pan2ヘルプファイルから、引数pos(位置)が-1(左)から+1(右)の間の数値を期待し、0が中心であることがわかります。そのため、SinOscを直接その引数に使用できます。sine oscillator はバイポーラ UGenであるため、デフォルトで-1〜+1の数値を出力します。

------

*マルチチャンネルパンニングについては、Pan4およびPanAzをご覧ください。上級ユーザーは、AmbisonicsのSuperColliderプラグインをご覧ください。



**p-79**



以下に、より詳細な例を示します。 のこぎり波は、非常に鋭いバンドパスフィルターを通過します（rq：0.01）。 ローカル変数を使用して、コードのさまざまな部分をモジュール化することに注意してください。
上記の例でできる限り分析して理解しようとしましょう。 次に、以下の質問に答えてください。

```c
(
x = {
	var lfn = LFNoise2.kr(1);
	var saw = Saw.ar(
	freq: 30,
	mul: LFPulse.kr(
	freq: LFNoise1.kr(1).range(1, 10),
	width: 0.1));
	var bpf = BPF.ar(in: saw, freq: lfn.range(500, 2500), rq: 0.01, mul: 20);
	Pan2.ar(in: bpf, pos: lfn);
}.play;
)
x.free;
```

質問：

（a）変数lfnは2つの異なる場所で使用されます。 どうして？ （結果はどうなりますか？）
（b）BPFのmul：引数を20から10、5、または1に変更するとどうなりますか？ なぜ20という高い数値が使用されたのですか？
（c）コードのどの部分がリズムを制御していますか？

回答はこのドキュメントの最後にあります。8



**p-80**



### 35 Mix と Splay

ここにクールなトリックがあります。 マルチチャンネル拡張を使用して複雑なサウンドを生成し、それをすべてMixたはSplayでモノラルまたはステレオにミックスダウンできます:

```c
// 5 channels output (watch Meter window)
a = { SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1) }.play;
a.free;
// Mix it down to mono:
b = { Mix(SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1)) }.play;
b.free;
// Mix it down to stereo (spread evenly from left to right)
c = { Splay.ar(SinOsc.ar([100, 300, 500, 700, 900], mul: 0.1)) }.play;
c.free
// Fun with Splay:
(
d = {arg fundamental = 110;
	var harmonics = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	var snd = BPF.ar(
		in: Saw.ar(32, LFPulse.ar(harmonics, width: 0.1)),
		freq: harmonics * fundamental,
		rq: 0.01,
		mul: 20);
	Splay.ar(snd);
}.play;
)
d.set(\fundamental, 100); // change fundamental just for fun
d.free;
```



**p-81**



最後の Splay の例で、マルチチャンネル拡張が機能しているのを見ることができますか？ 唯一の違いは、UGen で使用される前に、配列が最初に変数（harmonics）に格納されることです。 array harmonics には9つのアイテムがあるため、シンセは9チャンネルに拡張されます。 次に、.play の直前に、Splay は9つのチャンネルの配列を取り込み、ステレオにミックスダウンして、チャンネルを左から右に均等に展開します。*

Mix にはもう1つの素晴らしいトリックがあります：メソッド fill です。 シンセの配列を作成し、それを一度にモノラルにミックスダウンします。

```c
// Instant cluster generator
c = { Mix.fill(16, {SinOsc.ar(rrand(100, 3000), mul: 0.01)}) }.play;
c.free;
// A note with 12 partials of decreasing amplitudes
(
n = { Mix.fill(12, {arg counter;
	var partial = counter + 1; // we want it to start from 1, not 0
	SinOsc.ar(partial * 440, mul: 1/partial.squared) * 0.1
	})
}.play;
FreqScope.new;
)
n.free;
```



Mix.fill には、作成する配列のサイズと、配列を埋めるために使用される関数（中括弧）の2つのことを指定します。 上記の最初の例では、Mix.fill は関数を16回評価します。 関数には可変成分が含まれていることに注意してください。正弦発振器の周波数は、100から3000の間の任意の乱数にすることができます。それぞれが異なるランダム周波数を持つ16の正弦波が作成されます。 それらはすべてモノラルにミックスダウンされ、結果が左チャンネルで聞きこえます。 2番目の例は、関数が（ Array.fill のように）反復回数を追跡する counter 引数を取ることができることを示しています。

12個の sine オシレーターがハーモニックシリーズに続いて生成され、モノラルで単一のノートにミックスダウンされます。

------



*.play の前の最後の行は、Out.ar(0, Splay.ar(snd)) として明示的に記述できます。 SuperColliderが丁寧にギャップを埋め、そこに Out.ar(0...) を投入していることを忘れないでください。これは、シンセが、左 (bus 0) と右 (bus 1) のチャンネルで再生する必要があることを認識していることです。



**p-82**



### 36 Playing an audio file

まず、サウンドファイルをバッファにロードする必要があります。 Buffer.read の2番目の引数は、二重引用符 "" で囲まれたサウンドファイルのパスです。 コンピュータ上のWAVまたはAIFFファイルを指すように、それに応じて変更する必要があります。 バッファがロードされたら、PlayBuf UGen を使用してさまざまな方法でバッファを再生します。

| ヒント：コンピューターに保存されているサウンドファイルの正しいパスを取得する簡単な方法は、ファイルを空のSuperColliderドキュメントにドラッグすることです。 SCは既に二重引用符で囲まれた完全なパスを自動的に提供します！ |
| ------------------------------------------------------------ |
|                                                              |

```c
// buffersにロードします:
~buf1 = Buffer.read(s, "/home/Music/wheels-mono.wav"); // 1つのサウンドファイル
~buf2 = Buffer.read(s, "/home/Music/mussorgsky.wav"); // 別のサウンドファイル

// プレイバック:
{PlayBuf.ar(1, ~buf1)}.play; // number of channels and buffer
{PlayBuf.ar(1, ~buf2)}.play;

// ファイルの情報を得る:
[~buf1.bufnum, ~buf1.numChannels, ~buf1.path, ~buf1.numFrames];
[~buf2.bufnum, ~buf2.numChannels, ~buf2.path, ~buf2.numFrames];

// 'rate'によってプレイバックスピードを変える
{PlayBuf.ar(numChannels: 1, bufnum: ~buf1, rate: 2, loop: 1)}.play;
{PlayBuf.ar(1, ~buf1, 0.5, loop: 1)}.play; // play at half the speed
{PlayBuf.ar(1, ~buf1, Line.kr(0.5, 2, 10), loop: 1)}.play; // スピードアップ speeding up
{PlayBuf.ar(1, ~buf1, MouseY.kr(0.5, 3), loop: 1)}.play; // マウスコントロールで

// 方向を変える(reverse)
{PlayBuf.ar(1, ~buf2, -1, loop: 1)}.play; // 逆再生reverse sound
{PlayBuf.ar(1, ~buf2, -0.5, loop: 1)}.play; // play 半分のスピードで逆再生
```



**p-83**



### 37 Synth Nodes

前のPlayBufの例では、各行の後に [ctrl+.] を押してサウンドを停止する必要がありました。 他の例では、シンセを変数（ x = {WhiteNoise.ar}.playなど）に割り当てて、x.free で直接停止できるようにしました。
SuperColliderでシンセを作成するたびに、「サウンドエンジン」であるサーバーで実行されることがわかります。サーバーで実行されている各シンセは、ノードで表されます。 コマンド s.plotTree を使用して、このノードツリーを覗くことができます。 それを試してみてください。 NodeTreeという名前のウィンドウが開きます。

```c
// open the GUI
s.plotTree;
// run these one by one (don't stop the sound) and watch the Node Tree:
w = { SinOsc.ar(60.midicps, 0, 0.1) }.play;
x = { SinOsc.ar(64.midicps, 0, 0.1) }.play;
y = { SinOsc.ar(67.midicps, 0, 0.1) }.play;
z = { SinOsc.ar(71.midicps, 0, 0.1) }.play;
w.free;
x.free;
y.free;
z.free;
```



**p-84**



ノードツリーに表示されるすべての長方形は、シンセノードです。 各シンセには一時的な名前（temp_101、temp_102など）が付けられ、実行中はそこにとどまります。 4つのサインをもう一度再生して、 [ctrl+.] を押します（ノードツリーウィンドウを確認します）。 ショートカット [ctrl+.] は、サーバーで実行されているすべてのノードを一度に無慈悲に停止します。 一方、.freeメソッドを使用すると、よりこまかに、特定のノードを1つずつ解放できます。

重要なことの1つは、無音のみを生成している場合でも、シンセがサーバーで実行されたままになる可能性があることです。以下に例を示します。この WhiteNoise UGen の振幅は、2秒で0.2から0になります。その後、何も聞こえません。しかし、シンセノードはまだそこにあり、解放するまで消えません。

```c
1 // ノードツリーウィンドウを数秒間監視する
2 x = {WhiteNoise.ar(Line.kr(0.2, 0, 2))}.play;
3 x.free;
```

### 37.1 The glorious doneAction: 2

幸いなことに、シンセをよりスマートにする方法があります。たとえば、Line.krにジョブが終了したとき（0.2から0へのランプ）に通知するようにLine.krに依頼できると便利ですよね？そうなればシンセは自動的に解放されますね。
引数 doneAction: 2 を入力して、すべての問題を解決します。
以下の例を再生し、doneAction: 2 を使用した場合と使用しない場合の動作を比較します。

行を実行しながらノードツリーを見てみましょう。

```c
1 // doneAction: 2 無しで
2 {WhiteNoise.ar(Line.kr(0.2, 0, 2))}.play;
3 {PlayBuf.ar(1, ~buf1)}.play; // PS. これは、まだ前のセクションを引き継いで ~buf1 にサウンドファイルが読み込まれていることを前提としています
4
5// doneAction: 2 を使います
6 {WhiteNoise.ar(Line.kr(0.2, 0, 2, doneAction: 2))}.play;
7 {PlayBuf.ar(1, ~buf1, doneAction: 2)}.play;
```



**p-85**



 doneAction: 2 のシンセは、ジョブが完了するとすぐに（つまり、最初の例で Line.kr ランプが終了し、2番目の例のサウンドファイルの PlayBuf.ar が再生を終了するとすぐに）自動的に解放されます。この知識は、次のセクション「エンベロープ」で非常に役立ちます。

### 38 エンベロープ

これまでの例のほとんどは連続音でした。 音の振幅エンベロープを形作る方法を学ぶ時が来ました。始めるのに良い例は、パーカッシブ エンベロープです。

シンバルのクラッシュを想像してください。 音が無音から最大振幅になるまでにかかる時間は非常に短く、おそらく数ミリ秒です。 これは、attack time と呼ばれます。 シンバルの音が最大振幅から無音（ゼロ）に戻るまでにかかる時間は、もう少し長く、おそらく数秒です。 これは release time と呼ばれます。

振幅エンベロープは、単に音を生成するUGenの乗数（mul）として使用される時間とともに変化する数値と考えてください。 これらの数値は、SuperColliderが振幅を理解する方法であるため、0（無音）から1（フルアンプ）の間である必要があります。

これまでに、最後の例には既に振幅エンベロープが含まれていることに気付いたかもしれません。
{WhiteNoise.ar(Line.kr(0.2, 0, 2, doneAction: 2))}.play によって、2秒間でホワイトノイズの振幅を0.2から0に変更します。 ただし、Line.krは、非常に柔軟なタイプのエンベロープではありません。

Env は、あらゆる種類のエンベロープを定義するために常に使用するオブジェクトです。Env には多くの便利なメソッドがあります。 ここでは少しだけ見ます。 詳細については、Env ヘルプファイルをご覧ください。



**p-86**





### 38.1 Env.perc
Env.perc は、パーカッシブなエンベロープを取得する便利な方法です。それは、attackTime、releaseTime、level、および curve の4つの引数を取ります。シンセ以外の典型的なシェイプを見てみましょう。

```c
Env.perc.plot; // using all default args
Env.perc(0.5).plot; // attackTime: 0.5
Env.perc(attackTime: 0.3, releaseTime: 2, level: 0.4).plot;
Env.perc(0.3, 2, 0.4, 0).plot; // same as above, but curve:0 means straight lines
```


これで、次のようなシンセに簡単に接続できます:

```c
{PinkNoise.ar(Env.perc.kr(doneAction: 2))}.play; // default Env.perc args
{PinkNoise.ar(Env.perc(0.5).kr(doneAction: 2))}.play;
{PinkNoise.ar(Env.perc(0.3, 2, 0.4).kr(2))}.play;
{PinkNoise.ar(Env.perc(0.3, 2, 0.4, 0).kr(2))}.play;
```

Env.perc の直後に .kr(doneAction: 2) を追加するだけで、準備完了です。 実際、この場合は doneAction の明示的な宣言を削除して、シンプルに .kr(2) を使用することもできます。 .kr は、SCにこのエンベロープをコントロール レートで「実行」するように伝えています（これより前で見た他のコントロール レート信号と同様）。

### 38.2 Env.triangle
Env.triangle は、duration, level の2つの引数のみを取ります。 

例：

```c
// See it:
Env.triangle.plot;
// Hear it:
{SinOsc.ar([440, 442], mul: Env.triangle.kr(2))}.play;
// ところで、エンベロープはコードの任意の場所で乗数にすることができます
{SinOsc.ar([440, 442]) * Env.triangle.kr(2)}.play;
```



**p-87**



### 38.3 Env.linen

Env.linenは、アタック、サステイン部分、およびリリースを含むラインエンベロープについて説明しています。レベルと曲線の種類も指定できます。
例：

```c++
// See it: Env.linen.plot; // Hear it: SinOsc.ar([300, 350], mul: Env.linen(0.01, 2, 1,
0.2).kr(2)).play;
```



### 38.4 Env.pairs

さらに柔軟性が必要ですか？
Env.pairsを使用すると、任意の形状と期間のエンベロープを作成できます。
Env.pairsは、2つの引数を取ります。[time, level]ペアの配列、および曲線のタイプ(使用可能なすべての曲線タイプについては、Env Helpファイルを参照してください)。

```c++
(
{
	var env = Env.pairs([[0, 0], [0.4, 1], [1, 0.2], [1.1, 0.5], [2, 0]], \lin);
	env.plot;
	SinOsc.ar([440, 442], mul: env.kr(2));
}.play;
)
```



 次のようなペアの配列を読み取ります:

​		At time 0, be at level 0;

​		At time 0.4, be at level 1;

​		At time 1, be at level 0.2;

​		At time 1.1, be at level 0.5;

​		At time 2, be at level 0.



**p-88**



### 38.4.1 Envelopes—not just for amplitude

これらの同じシェイプを使用して振幅以外の何かをコントロールすることを妨げるものは何もありません。
必要な数値の範囲に合わせてスケーリングする必要があります。
たとえば、エンベロープを作成して、時間の経過に伴う周波数の変化をコントロールできます。

```c++
(
{
	var freqEnv = Env.pairs([[0, 100], [0.4, 1000], [0.9, 400], [1.1, 555], [2,
440]], \lin);
	SinOsc.ar(freqEnv.kr, mul: 0.2);
}.play;
)
```

エンベロープは、時間の経過とともに変化する必要があるシンセパラメーターをコントロールする強力な方法です。



### 38.5 ADSR Envelope

これまでに表示されたすべてのエンベロープには、1つの共通点があります。それらは、事前定義された固定の duration を持っています。 ただし、このタイプのエンベロープが適切でない場合があります。 たとえば、MIDIキーボードで演奏しているとします。 キーを押すと、ノートの attack がトリガーされます。 リリースは、キーから指を離したときです。 ただし、事前には指がキー押している時間はわかりません。 この場合に必要なのは、いわゆる“持続エンベロープ”です。



**p-89**



ASR（アタック、サステイン、リリース）がエンベロープに適合します。 より一般的なバリエーションは、ADSRエンベロープ（Attack、Decay、Sustain、Release）です。 両方見てみましょう。

```c++
// ASR
// Play note ('press key')
// attackTime: 0.5 seconds, sustainLevel: 0.8, releaseTime: 3 seconds
x = {arg gate = 1, freq = 440; SinOsc.ar(freq: freq, mul: Env.asr(0.5, 0.8, 3).kr(
	doneAction: 2, gate: gate))}.play;
// Stop note ('finger off the key' 􀀀 activate release stage)
x.set(\gate, 0); // alternatively, x.release

// ADSR (attack, decay, sustain, release)
// Play note:
(
d = {arg gate = 1;
	var snd, env;
	env = Env.adsr(0.01, 0.4, 0.7, 2);
	snd = Splay.ar(BPF.ar(Saw.ar((32.1, 32.2..33)), LFNoise2.kr(12).range(100,1000), 0.05, 10));
	Out.ar(0, snd * env.kr(doneAction: 2, gate: gate));
}.play;
)
// Stop note:
d.release; // this is equivalent to d.set(\gate, 0);
```

Key concepts:

Attack　ゼロ（無音）からピーク振幅までにかかる時間（秒）

Decay　ピーク振幅からサステイン振幅まで下降するのにかかる時間（秒）

Sustain　音を保持する振幅（0〜1）（重要：これは時間とは関係ありません）

Release　サステインレベルからゼロ（無音）になるまでにかかる時間（秒単位）。



**p-90**



持続エンベロープには事前にわかっている total duration がないため、いつスタートする(attackをトリガーする)か、いつ停止する(release をトリガーする)かを通知する必要があります。この通知は gate と呼ばれます。gate は、エンベロープに"開く"(1)と"閉じる"(0)を指示するものであり、音を開始および停止します。

ASRまたはADSRエンベロープをシンセで機能させるには、gate 引数を宣言する必要があります。通常、シンセの再生をすぐに開始するため、デフォルトは gate = 1 です。シンセを停止したい場合は、単に .release または .set(\gate,0) メッセージを送信します。エンベロープのリリース部分がトリガーされます。たとえば、リリース時間が3の場合、メッセージ .set(\gate,0) を送信した瞬間から音が消えるまで3秒かかります。



### 38.6 EnvGen

記録については、以下のコードに示すように、エンベロープを生成するためにこのセクションで学んだ構成はショートカット（短縮）であることを知っておく必要があります。

```c++
// これは:
{ SinOsc.ar * Env.perc.kr(doneAction: 2) }.play;
// ... これのショートカットです:
{ SinOsc.ar * EnvGen.kr(Env.perc, doneAction: 2) }.play;
```

EnvGen は、Env によって定義されたブレークポイントエンベロープを実際に再生する UGen です。すべての実用的な目的のために、ショートカット（短縮形）を引き続き使用できます。 ただし、ヘルプファイルやその他のオンライン例で EnvGen が使用されていることがよくあるので、これらの表記は同等であることを知っておくと便利です。



**p-91**



### 39 シンセの定義

  これまで、シンセをシームレスに定義し、すぐに再生してきました。さらに、.set メッセージにより、シンセコントロールをリアルタイムで変更できる柔軟性が得られました。ただし、シンセを最初に定義し(すぐに再生せずに)、後でのみ再生したい場合があります。つまり、レシピを書き留める瞬間(シンセの定義)とケーキを焼く瞬間(サウンドを作成する)を分離する必要があるということです。

### 39.1 SynthDefとSynth

 SynthDef は、シンセの"レシピを書く"ために使用するものです。その後、Synth で再生できます。以下に簡単な例を示します。

```c++
// Synth definition with SynthDef object
SynthDef("mySine1", {Out.ar(0, SinOsc.ar(770, 0, 0.1))}).add;
// Play a note with Synth object
x = Synth("mySine1");
x.free;

// A slightly more flexible example using arguments
// and a self􀀀terminating envelope (doneAction: 2)
SynthDef("mySine2", {arg freq = 440, amp = 0.1;
	var env = Env.perc(level: amp).kr(2);
	var snd = SinOsc.ar(freq, 0, env);
	Out.ar(0, snd);
}).add;

Synth("mySine2"); // using default values
Synth("mySine2", [\freq, 770, \amp, 0.2]);
Synth("mySine2", [\freq, 415, \amp, 0.1]);
Synth("mySine2", [\freq, 346, \amp, 0.3]);
Synth("mySine2", [\freq, rrand(440, 880)]);
```



**p-92**



SynthDef の最初の引数は、シンセのユーザー定義名です。
2番目の引数は UGen グラフを指定する関数です(これが UGen の組み合わせが呼び出される方法です)。Out.ar を明示的に使用して、信号を送信するバスを指定する必要があることに注意してください。最後に、SynthDefはメッセージ .add を最後に受け取ります。つまり、SCが認識しているシンセのコレクションに追加することになります。

これは、SuperColliderを終了するまで有効です。
SynthDef で1つ以上のシンセ定義を作成した後、Synth でそれらを再生できます。

最初の引数は使用するシンセ定義の名前で、2番目の（オプション）引数は指定したいパラメーター（ freq、amp など）を持つ配列です。

### 39.2 Example
Here’s a longer example. After the SynthDef is added, we use an array trick to create a 6-note chord with random pitches and amplitudes. Each synth is stored in one of the slots of the array, so we can release them independently.

**p-93**

```c++
// Create SynthDef
(
SynthDef("wow", {arg freq = 60, amp = 0.1, gate = 1, wowrelease = 3;
var chorus, source, filtermod, env, snd;
chorus = freq.lag(2) * LFNoise2.kr([0.4, 0.5, 0.7, 1, 2, 5, 10]).range(1,1.02);
source = LFSaw.ar(chorus) * 0.5;
filtermod = SinOsc.kr(1/16).range(1, 10);
	env = Env.asr(1, amp, wowrelease).kr(2, gate);
	snd = LPF.ar(in: source, freq: freq * filtermod, mul: env);
Out.ar(0, Splay.ar(snd))
}).add;
)

// Watch the Node Tree
s.plotTree;

// Create a 6􀀀note chord
a = Array.fill(6, {Synth("wow", [\freq, rrand(40, 70).midicps, \amp, rrand(0.1, 0.5)
])}); // all in a single line

// Release notes one by one
a[0].set(\gate, 0);
a[1].set(\gate, 0);
a[2].set(\gate, 0);
a[3].set(\gate, 0);
a[4].set(\gate, 0);
a[5].set(\gate, 0);

// ADVANCED: run 6􀀀note chord again, then evaluate this line.
// Can you figure out what is happening?
SystemClock.sched(0, {a[5.rand].set(\midinote, rrand(40, 70)); rrand(3, 10)});
```

To help you understand the SynthDef above:
• The resulting sound is the sum of seven closely-tuned sawtooth oscillators going througha low pass filter.
• These seven oscillators are created through multichannel expansion.



**p-94**



• What is the variable chorus? It is the frequency multiplied by a LFNoise2.kr. Themultichannel expansion starts here, because an array with 7 items is given as an argument to LFNoise2. The result is that seven copies of LFNoise2 are created, each one running at a different speeds taken from the list [0.4, 0.5, 0.7, 1, 2, 5, 10]. Their outputs areconstrained to the range 1.0 to 1.02.
• The source sound LFSaw.ar takes the variable chorus as its frequency. In a concrete
example: for a freq value of 60 Hz, the variable chorus would result in an expression like



```c++
60  [1:01; 1:009; 1:0; 1:02; 1:015; 1:004; 1:019]
```

in which the numbers inside the list would be constantly changing up and down according to the speeds of each LFNoise2. The final result is a list of seven frequencies always sliding between 60 and 61.2 (60 * 1.02). This is called chorus effect, thus the variable name.
• When the variable chorus is used as freq of LFSaw.ar, multichannel expansion happens: we have now seven sawtooth waves with slightly different frequencies.
• The variable filtermod is just a sine oscillator moving very slowly (1 cycle over 16 seconds), with its output range scaled to 1-10. This will be used to modulate the cutoff frequency of the low pass filter.
• The variable snd holds the low pass filter (LPF), which takes source as input, and filters out all frequencies above its cutoff frequency. This cutoff is not a fixed valued: it is the expression freq * filtermod. So in the example assuming freq = 60, this becomes a number between 60 and 600. Remember that filtermod is a number oscillating between 1 and 10, so the multiplication would be 60 * (1 to 10).

**p-95**

• LPF also multichannel expands to seven copies. The amplitude envelope env is also applied right there.
• Finally, Splay takes this array of seven channels and mixes it down to stereo.

### 39.3 Under the hood
This two-step process of first creating the SynthDef (with a unique name) and then calling aSynth is what SC does all the time when you write simple statements like {SinOsc.ar}.play.
SuperCollider unpacks that into (a) the creation of a temporary SynthDef, and (b) the immediate playback of it (thus the names temp_01, temp_02 that you see in the Post window). All of it behind the scenes, for your convenience.

```c++
1 // When you do this:
2 {SinOsc.ar(440)}.play;
3 // What SC is doing is this:
4 {Out.ar(0, SinOsc.ar(440))}.play;
5 // Which in turn is really this:
6 SynthDef("tempName", {Out.ar(0, SinOsc.ar(440))}).play;
78
// And all of them are shortcuts to this two􀀀step operation:
9 SynthDef("tempName", {Out.ar(0, SinOsc.ar(440))}).add; // create a synth definition
10 Synth("tempName"); // play it
```

### 40 Pbind can play your SynthDef
One of the beauties of creating your synths as SynthDefs is that you can use Pbind to play them.
Assuming the "wow" SynthDef is still loaded in memory (it should, unless you quit and reopened SC after the last example), try the Pbinds below:

**p-96**

```c++
(
Pbind(
\instrument, "wow",
\degree, Pwhite(-7, 7),
\dur, Prand([0.125, 0.25], inf),
\amp, Pwhite(0.5, 1),
\wowrelease, 1
).play;
)

(
Pbind(
\instrument, "wow",
\scale, Pstutter(8, Pseq([
Scale.lydian,
Scale.major,
Scale.mixolydian,
Scale.minor,
Scale.phrygian], inf)),
\degree, Pseq([0, 1, 2, 3, 4, 5, 6, 7], inf),
\dur, 0.2,
\amp, Pwhite(0.5, 1),
\wowrelease, 4,
\legato, 0.1
).play;
)
```

When using Pbind to play one of your custom SynthDefs, just keep in mind the followingpoints:
• Use the Pbind key \instrument to declare the name of your SynthDef.



**p-97**



• All the arguments of your SynthDef are accessible and controllable from inside Pbind:
simply use them as Pbind keys. For example, notice the argument called \wowrelease used above. It is not one of the default keys understood by Pbind—rather, it is unique to the synth definition wow (the silly name was chosen on purpose).
• In order to use all of the pitch conversion facilities of Pbind (the keys \degree, \note, and \midinote), make sure your SynthDef has an argument input for freq (it has to bespelled exactly like that). Pbind will do the math for you.
• If using a sustained envelope such as Env.adsr, make sure your synth has a default argument gate = 1 (gate has to be spelled exactly like that, because Pbind uses it behind the scenes to stop notes at the right times).
• If not using a sustained envelope, make sure your SynthDef includes a doneAction: 2 in an appropriate UGen, in order to automatically free synth nodes in the server.

Exercise: write one or more Pbinds to play the "pluck" SynthDef provided below. For the
mutedString argument, try values between 0.1 and 0.9. Have one of your Pbinds play a slow sequence of chords. Try arpeggiating the chords with \strum.

```c++
(
SynthDef("pluck", {arg amp = 0.1, freq = 440, decay = 5, mutedString = 0.1;
var env, snd;
env = Env.linen(0, decay, 0).kr(doneAction: 2);
snd = Pluck.ar(
in: WhiteNoise.ar(amp),
trig: Impulse.kr(0),
maxdelaytime: 0.1,
delaytime: freq.reciprocal,
decaytime: decay,
coef: mutedString);
Out.ar(0, [snd, snd]);
}).add;
)
```

**p-98**


### 41 Control Buses
Earlier in this tutorial we talked about Audio Buses (section 30) and the Bus Object (section33). We chose to leave aside the topic of Control Buses at that time in order to focus on the concept of audio routing.
Control Buses in SuperCollider are for routing control signals, not audio. Except for this difference, there is no other practical or conceptual distinction between audio and control buses.
You create and manage a control bus the same way you do with audio buses, simply using .kr instead of .ar. SuperCollider has 4096 control buses by default.
The first part of the example below uses an arbitrary bus number just for the sake of demonstration.The second part uses the Bus object, which is the recommended way of creating buses.


```c++
// Write a control signal into control bus 55
{Out.kr(55, LFNoise0.kr(1))}.play;
// Read a control signal from bus 55
{In.kr(55).poll}.play;

// Using the Bus object
~myControlBus = Bus.control(s, 1);
{Out.kr(~myControlBus, LFNoise0.kr(5).range(440, 880))}.play;
{SinOsc.ar(freq: In.kr(~myControlBus))}.play;
```

The next example shows a single control signal being used to modulate two different synths atthe same time. In the Blip synth, the control signal is rescaled to control number of harmonicsbetween 1 and 10. In the second synth, the same control signal is rescaled to modulate the frequency of the Pulse oscillator.



**p-99**



```c++
// Create the control bus
~myControl = Bus.control(s, 1);

// Feed the control signal into the bus
c = {Out.kr(~myControl, Pulse.kr(freq: MouseX.kr(1, 10), mul: MouseY.kr(0, 1)))}.play;

// Play the sounds being controlled
// (move the mouse to hear changes)
(
{
	Blip.ar(
		freq: LFNoise0.kr([1/2, 1/3]).range(50, 60),
		numharm: In.kr(~myControl).range(1, 10),
		mul: LFTri.kr([1/4, 1/6]).range(0, 0.1))
}.play;

{
	Splay.ar(
		Pulse.ar(
			freq: LFNoise0.kr([1.4, 1, 1/2, 1/3]).range(100, 1000) * In.kr(~myControl).range(0.9, 1.1),
			mul: SinOsc.ar([1/3, 1/2, 1/4, 1/8]).range(0, 0.03))
)
}.play;
)

// Turn off control signal to compare
c.free;
```

**p-100**




